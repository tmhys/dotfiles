"
" â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
" â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•
" â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘
" â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
"  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
"   â•šâ•â•â•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•
" Last Change: 02-May-2019.
" Maintainer: TH

"æœ€åˆã«æ›¸ãå¿…è¦ã‚ã‚Š
set encoding=utf8

"ãã®ä»–ã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
runtime! userautoload/*.vim

""dein{{{
if executable('git')
	if &compatible
		set nocompatible
	endif

	" dein path
	let s:dein_dir = expand('~/.cache/dein')
	let s:dein_repo_dir = s:dein_dir . '/repos/github.com/Shougo/dein.vim'

	" install dein.vim if not found
	if &runtimepath !~# '/dein.vim'
	  if !isdirectory(s:dein_repo_dir)
	    execute '!git clone https://github.com/Shougo/dein.vim' s:dein_repo_dir
	  endif
	  set runtimepath+=~/.cache/dein/repos/github.com/Shougo/dein.vim
	endif

	if dein#load_state(s:dein_dir)
	  call dein#begin(s:dein_dir)

	  "tomlè¨­å®š{{{
	  "Plugin list
	  let g:rc_dir    = expand('~/.vim/rc')
	  let s:toml      = g:rc_dir . '/dein.toml'
	  let s:color     = g:rc_dir . '/color.toml'
	  let s:lazy_toml = g:rc_dir . '/dein_lazy.toml'

	  "ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ã¦ãŠã
	  call dein#load_toml(s:toml,      {'lazy': 0})
	  call dein#load_toml(s:color,     {'lazy': 0})
	  call dein#load_toml(s:lazy_toml, {'lazy': 1})
	 " }}}

	  call dein#end()
	  call dein#save_state()
	endif

	"Required
	filetype plugin indent on
	syntax enable

	" If you want to install not installed plugins on startup.
	if dein#check_install()
	  call dein#install()
	endif

command! DU :call dein#update()
command! DR :call dein#recache_runtimepath()

endif
"}}}

"åŸºæœ¬è¨­å®š{{{
"ã‚«ãƒ©ãƒ¼è¨­å®š{{{
set background=dark "light dark
"let ayucolor="light"  "mirage dark
"colorscheme ayu "nord atom-dark badwolf hybrid newspaper wombat molokai solarized evening desert morning elford koehler landscape papercolor one seoul256
"Chroshä¸Šã§256ã‚«ãƒ©ãƒ¼ã«å¿…è¦
set termguicolors
"}}}

let g:vimproc#download_windows_dll = 1

"ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ã‚¤ãƒ³å¸¸æ™‚è¡¨ç¤º
set laststatus=2

"ãƒ©ã‚°å¯¾ç­–
set lazyredraw

"ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆé–¢ä¿‚{{{
syntax on
set autoindent
"set expandtab
set tabstop=4
set shiftwidth=4
"ã‚«ãƒ¼ã‚½ãƒ«ãƒ©ã‚¤ãƒ³ã¯vim-auto-cursorlineã«çµ±åˆ
"set cursorline
"set cursorcolumn
set number
set signcolumn=yes

filetype plugin on
"}}}

"Quickfixã‚¦ã‚£ãƒ³ãƒ‰ã‚¦é–‹ã{{{
autocmd QuickFixCmdPost *grep* cwindow
"}}}

"ripgrep{{{
if executable('rg')
    set grepprg=rg\ --vimgrep\ --no-heading
    set grepformat=%f:%l:%c:%m,%f:%l:%m
endif
"}}}

"{{{
" Similarly, we can apply it to fzf#vim#grep. To use ripgrep instead of ag:
command! -bang -nargs=* Rg
  \ call fzf#vim#grep(
  \   'rg --column --line-number --no-heading --color=always '.shellescape(<q-args>), 1,
  \   <bang>0 ? fzf#vim#with_preview('up:60%')
  \           : fzf#vim#with_preview('right:50%:hidden', '?'),
  \   <bang>0)
"}}}

"ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜å…ˆå¤‰æ›´{{{
"augroup vimrc-auto-mkdir  " {{{
"  autocmd!
"  autocmd BufWritePre * call s:auto_mkdir(expand('<afile>:p:h'), v:cmdbang)
"  function! s:auto_mkdir(dir, force)  " {{{
"    if !isdirectory(a:dir) && (a:force ||
"    \    input(printf('"%s" does not exist. Create? [y/N]', a:dir)) =~? '^y\%[es]$')
"      call mkdir(iconv(a:dir, &encoding, &termencoding), 'p')
"    endif
"  endfunction  " }}}
"augroup END  " }}}

let $DATE = strftime("%Y%m%d_%H%M%S")

set backup
set writebackup
set backupdir=$HOME/.vimbackup
au BufWritePre * let &bex = '.' .strftime("%Y%m%d_%H%M%S")
set undodir=$HOME/.vimbackup
set undofile
set noswapfile

"è‡ªå‹•çš„ã«ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¿å­˜{{{
au VimLeave * cclose
au VimLeave * NERDTreeClose
au VimLeave	* mks! ~/.vim/session/$DATE.vim
"}}}

"å¯¾ã«ãªã‚‹æ‹¬å¼§ç‚¹æ»…{{{
set showmatch
set matchtime=1
"}}}

"æ–‡æœ«ã‚¹ãƒšãƒ¼ã‚¹å‰Šé™¤{{{
autocmd BufWritePre * :%s/\s\+$//ge
"}}}

"è£œå®Œ{{{
set completeopt=menuone
for k in split("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",'\zs')
  exec "imap " . k . " " . k . "<C-N><C-P>"
endfor

let g:python3_host_prog='C:\Python37\python.exe'
set pythonthreedll=C:\Python37\python37.dll
"}}}

"ç›¸å¯¾è¡Œç•ªå·è¡¨ç¤º&ãƒˆã‚°ãƒ«
"nnoremap <F3> :<C-u>setlocal relativenumber!<CR>

"åŒæœŸã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒˆã‚°ãƒ«
nnoremap <F4> :<C-u>set scrollbind!<CR>

"IMEçŠ¶æ…‹ã«å¿œã˜ãŸã‚«ãƒ¼ã‚½ãƒ«è‰²è¨­å®š{{{
if has('multi_byte_ime')
  highlight Cursor guifg=#000d18 guibg=#8faf9f gui=bold
  highlight CursorIM guifg=NONE guibg=#ecbcbc
endif
"}}}

"æŠ˜ã‚ŠãŸãŸã¿è¨­å®š{{{
au FileType vim setlocal foldmethod=marker
au FileType seq setlocal foldmethod=marker
"}}}

"}}}

set scrolloff=10
set backspace=indent,eol,start
set matchpairs+=ã€Œ:ã€,ã€:ã€,ï¼ˆ:ï¼‰,ã€:ã€‘,ã€Š:ã€‹,ã€ˆ:ã€‰,ï¼»:ï¼½,â€˜:â€™,â€œ:â€,ï½›:ï½
"set virtualedit=all
set ignorecase
set smartcase

" çµ‚äº†æ™‚ã«ä¿å­˜ã™ã‚‹ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¨­å®šã™ã‚‹{{{
let g:restart_sessionoptions
    \ = 'blank,buffers,curdir,folds,help,localoptions,tabpages'
"}}}

"ã‚«ãƒ¬ãƒ³ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’æ–°è¦ã‚¿ãƒ–ã§é–‹ãç›´ã™{{{
if v:version >= 700
    nnoremap <M-n> :call OpenNewTab()<CR>
    function! OpenNewTab()
        let f = expand("%:p")
        execute ":q"
        execute ":tabnew ".f
    endfunction
endif
"}}}

"}}}

"""ã‚­ãƒ¼ãƒãƒƒãƒ—{{{
"command line window
"nnoremap : q:a
"nnoremap / q/a

" for masui special.
noremap g<CR> g;
"Quickfixã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã¨å¹²æ¸‰ã™ã‚‹
"nnoremap <CR> :<C-u>w<CR>

"è¡Œæœ«ã¾ã§ãƒ¤ãƒ³ã‚¯
nnoremap Y y$
"xã¨sã§ãƒ¤ãƒ³ã‚¯ã—ãªã„
nnoremap x "_x
nnoremap s "_s
nnoremap S "_S

"---<F6>ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’æŒ¿å…¥{{{
nmap <F6> <ESC>a<C-R>=strftime("%Y/%m/%d %H:%M")<CR><ESC>
inoremap <F6> <ESC>a<C-R>=strftime("%Y/%m/%d %H:%M")<CR>
nmap <F6>a <ESC>a<C-R>=strftime("%Y/%m/%d %H:%M")<CR> appended by <ESC>
inoremap <F6>a <ESC>a<C-R>=strftime("%Y/%m/%d %H:%M")<CR> appended by
nmap <F6>m <ESC>a<C-R>=strftime("%Y/%m/%d %H:%M")<CR> modified by <ESC>
inoremap <F6>m <ESC>a<C-R>=strftime("%Y/%m/%d %H:%M")<CR> modified by
"}}}

"ESCã‚­ãƒ¼é€£æ‰“
nnoremap <silent> <ESC><ESC> :<C-u>nohlsearch<CR>:Undiff<CR>
nnoremap <silent> <ESC><ESC><ESC><ESC> :Restart<CR>

"jj,kkã§Ecs
inoremap jj <Esc>
inoremap hhh <Esc>
inoremap lll <Esc>
inoremap kkk <Esc>

"ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ç§»å‹•
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
nnoremap <C-h> <C-w>h

" j, k ã«ã‚ˆã‚‹ç§»å‹•ã‚’æŠ˜ã‚Šè¿”ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã§ã‚‚è‡ªç„¶ã«æŒ¯ã‚‹èˆã†ã‚ˆã†ã«å¤‰æ›´
nnoremap j gj
nnoremap k gk
"S-h,S-lã§è¡Œé ­ã€è¡Œæœ«
nnoremap <S-h> ^
nnoremap <S-l> $
" vã‚’äºŒå›ã§è¡Œæœ«ã¾ã§é¸æŠ
vnoremap v $h
" æ¤œç´¢å¾Œã«ã‚¸ãƒ£ãƒ³ãƒ—ã—ãŸéš›ã«æ¤œç´¢å˜èªã‚’ç”»é¢ä¸­å¤®ã«æŒã£ã¦ãã‚‹
nnoremap n nzz
nnoremap N Nzz
"ã‚¤ãƒ³ã‚µãƒ¼ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã‚‚ç§»å‹•
inoremap <c-j> <down>
inoremap <c-k> <up>
inoremap <c-h> <left>
inoremap <c-l> <right>

" TABã«ã¦å¯¾å¿œãƒšã‚¢ã«ã‚¸ãƒ£ãƒ³ãƒ—
nnoremap <TAB> %
vnoremap <TAB> %

" è¡Œã‚’ç§»å‹•
nnoremap <C-Up> "zdd<Up>"zP
nnoremap <C-Down> "zdd"zp
" è¤‡æ•°è¡Œã‚’ç§»å‹•
vnoremap <C-Up> "zx<Up>"zP`[V`]
vnoremap <C-Down> "zx"zp`[V`]
"æ–°è¦ã‚¿ãƒ–
"noremap <Space>tn :<C-u>tabnew<CR> :UniteStartup<CR>
noremap <Space>tn :<C-u>tabnew<CR>
nnoremap <C-Tab> gt
nnoremap <S-C-Tab> gT

""ç¸¦åˆ†å‰²ç‰ˆgf
nnoremap gs :vertical wincmd f<CR>

"æœ€åˆã«ãƒ¤ãƒ³ã‚¯ã—ãŸæ–‡å­—åˆ—ã‚’ç¹°ã‚Šè¿”ã—ãƒšãƒ¼ã‚¹ãƒˆ
vnoremap <Space>p "0p

"ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªè‡ªå‹•ã§ç§»å‹•
set autochdir&vim

"<Space>cd ã§ç·¨é›†ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¸ã¨ç§»å‹•{{{
command! -nargs=? -complete=dir -bang CD  call s:ChangeCurrentDir('<args>', '<bang>')
function! s:ChangeCurrentDir(directory, bang)
    if a:directory == ''
        lcd %:p:h
    else
        execute 'lcd' . a:directory
    endif
    if a:bang == ''
        pwd
    endif
endfunction

" Change current directory.
nnoremap <silent> <Space>cd :<C-u>CD<CR>
"}}}

"ã‚«ãƒ¼ã‚½ãƒ«ä¸‹ã®å˜èªã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹
nnoremap <silent> <Space><Space> *N

"ã‚«ãƒ¼ã‚½ãƒ«ä¸‹ã®å˜èªã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆã—ã¦ã‹ã‚‰ç½®æ›ã™ã‚‹
nmap # <Space><Space>:%s/<C-r>///g<Left><Left>

"1è¡ŒæŒ¿å…¥ã™ã‚‹
nnoremap <Space>o :<C-u>call append(expand('.'), '')<Cr>j

"æ”¹è¡Œã™ã‚‹
nnoremap <M-o> i<CR><ESC>

"ESCã§ç¢ºå®Ÿã«IMEã‚ªãƒ•
inoremap <ESC> <ESC>:set iminsert=0<CR>

"æ‹¬å¼§è£œå®Œ{{{
inoremap { {}<ESC>i
inoremap [ []<ESC>i
inoremap ( ()<ESC>i
inoremap < <><ESC>i
inoremap * **<ESC>i
inoremap ' ''<ESC>i
"}}}

""VDsplitã‚’Winmergeãƒ©ã‚¤ã‚¯ã«{{{
nnoremap <M-j> ]c
nnoremap <M-k> [c
nnoremap <M-h> <C-w>hdo
nnoremap <M-l> <C-w>hdp
"}}}

""vimrcã®ç·¨é›†å†èª­ã¿è¾¼ã¿{{{
"ç·¨é›†
command! Evimrc :e $MYVIMRC
command! Egvimrc :e $MYGVIMRC
command! Etoml :e C:\Users\thtom\.vim\rc\dein.toml
command! Eltoml :e C:\Users\thtom\.vim\rc\dein_lazy.toml
"command! Evimrc :e  $HOME/dotfiles/_vimrc
"command! Egvimrc :e $HOME/dotfiles/_gvimrc
command! Esysseq :e $VIM/vim81/userautoload/SysSeq.vim
"ä¿å­˜ã—ãŸã‚‰å†èª­ã¿è¾¼ã¿
augroup reload_vimrc
	autocmd!
	autocmd BufWritePost $MYVIMRC nested source $MYVIMRC
	autocmd BufWritePost $MYVIMRC nested source $MYGVIMRC
	autocmd BufWritePost $MYVIMRC nested source $MYGVIMRC
	autocmd BufWritePost $MYVIMRC nested call lightline#update()
	autocmd BufWritePost C:\Users\thtom\.vim\rc\dein.toml nested source $MYVIMRC
	autocmd BufWritePost C:\Users\thtom\.vim\rc\dein.toml nested call dein#recache_runtimepath()
	autocmd BufWritePost C:\Users\thtom\.vim\rc\dein_lazy.toml nested source $MYVIMRC
	autocmd BufWritePost C:\Users\thtom\.vim\rc\dein_lazy.toml nested call dein#recache_runtimepath()
	autocmd BufWritePost $MYGVIMRC nested source $MYGVIMRC
	autocmd BufWritePost SysSeq.vim nested source $MYGVIMRC
	autocmd BufWritePost SysSeq.vim nested source $MYGVIMRC
augroup END
"}}}

"{{{Quickfix windowãƒˆã‚°ãƒ«
function! s:toggle_quickfix_window()
  let _ = winnr('$')
  cclose
  if _ == winnr('$')
  cwindow
  endif
endfunction
"}}}
nnoremap <M-q> :<C-u>call <SID>toggle_quickfix_window()<CR>

"QuickFix æ¨ªç”»é¢åˆ†å‰²ã§çµæœã‚’è¡¨ç¤º
au FileType qf nnoremap <S-CR> <C-w><CR><C-w>L

" ãƒãƒ¼ã‚¯è¨­å®š : {{{
" åŸºæœ¬ãƒãƒƒãƒ—
nnoremap [Mark] <Nop>
nmap m [Mark]

" ç¾åœ¨ä½ç½®ã‚’ãƒãƒ¼ã‚¯
if !exists('g:markrement_char')
    let g:markrement_char = [
    \     'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    \     'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
    \ ]
endif
nnoremap <silent>[Mark]m :<C-u>call <SID>AutoMarkrement()<CR>
function! s:AutoMarkrement()
    if !exists('b:markrement_pos')
        let b:markrement_pos = 0
    else
        let b:markrement_pos = (b:markrement_pos + 1) % len(g:markrement_char)
    endif
    execute 'mark' g:markrement_char[b:markrement_pos]
    echo 'marked' g:markrement_char[b:markrement_pos]
endfunction

" æ¬¡/å‰ã®ãƒãƒ¼ã‚¯
nnoremap [Mark]n ]`
nnoremap [Mark]N [`

" ä¸€è¦§è¡¨ç¤º
nnoremap [Mark]l :<C-u>marks<CR>

" å‰å›çµ‚äº†ä½ç½®ã«ç§»å‹•
autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line('$') | exe 'normal g`"' | endif

" ãƒãƒƒãƒ•ã‚¡èª­ã¿è¾¼ã¿æ™‚ã«ãƒãƒ¼ã‚¯ã‚’åˆæœŸåŒ–
autocmd BufReadPost * delmarks!

" }}}

""ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ{{{
autocmd BufNewFile,BufRead *.rb nnoremap <C-e> :!ruby %<CR>
autocmd BufNewFile,BufRead *.py nnoremap <C-e> :!py -3 %<CR>
autocmd BufNewFile,BufRead *.pl nnoremap <C-e> :!perl %<CR>
autocmd BufNewFile,BufRead *.cs nnoremap <C-e> :!csc /target:winexe %<CR>
autocmd BufNewFile,BufRead *.js nnoremap <C-e> :!electron .<CR>
"}}}
"}}}

"ctags{{{
let g:tagbar_ctags_bin = 'C:\tools\ctags58j2bin\ctags.exe'
set fileformats=unix,dos,mac
set fileencodings=utf-8,sjis

set tags=.tags;$HOME

function! s:execute_ctags() abort
  " æ¢ã™ã‚¿ã‚°ãƒ•ã‚¡ã‚¤ãƒ«å
  let tag_name = '.tags'
  " ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’é¡ã‚Šã€ã‚¿ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¢ã—ã€ãƒ‘ã‚¹å–å¾—
  let tags_path = findfile(tag_name, '.;')
  " ã‚¿ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ
  if tags_path ==# ''
    return
  endif

  " ã‚¿ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹ã‚’å–å¾—
  " `:p:h`ã®éƒ¨åˆ†ã¯ã€:h filename-modifiersã§ç¢ºèª
  let tags_dirpath = fnamemodify(tags_path, ':p:h')
  " è¦‹ã¤ã‹ã£ãŸã‚¿ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ç§»å‹•ã—ã¦ã€ctagsã‚’ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å®Ÿè¡Œï¼ˆã‚¨ãƒ©ãƒ¼å‡ºåŠ›ç ´æ£„ï¼‰
  execute 'silent !cd' tags_dirpath '&& ctags -R -f' tag_name '2> /dev/null &'
endfunction

augroup ctags
  autocmd!
  autocmd BufWritePost * call s:execute_ctags()
augroup END
"}}}

"{{{å¤–éƒ¨ã‚½ãƒ•ãƒˆ
if hostname()!=?'localhost'
	"WinMerge
	command! WinMerge :! C:\"Program Files"\WinMerge\WinMergeU /e/u/wr/maximize/fl "%:p:t"
	"ImageJ ãƒã‚¯ãƒ­å®Ÿè¡Œ
	"command! ImageJ :
endif
"}}}

"deinãŒãªã„ã¨ãã®å„ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®š{{{
if !executable('git')
"switch{{{
let g:switch_mapping = "-"
let g:switch_custom_definitions =
    \ [
    \   ['on', 'off']
    \ ]
"}}}

"NERDTree{{{
map <C-n> :NERDTreeToggle<CR>
nnoremap <silent> <expr> <C-n> g:NERDTree.IsOpen() ? "\:NERDTreeClose<CR>" : bufexists(expand('%')) ? "\:NERDTreeFind<CR>" : "\:NERDTree<CR>"
"""bookmarkåˆæœŸè¡¨ç¤º
let g:NERDTreeShowBookmarks=1
"lagå¯¾ç­–
let g:NERDTreeLimitedSyntax = 1

let NERDTreeIgnore = ['.dat$','.exe$','.dbg$','.bak$','.dll$']


""NERDTreeçŸ¢å°å¤‰æ›´{{{
let g:WebDevIconsNerdTreeAfterGlyphPadding = ''
let g:NERDTreeDirArrows = 1
let g:NERDTreeDirArrowExpandable  = 'â–¶'
let g:NERDTreeDirArrowCollapsible = 'â–¼'
"let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols['seq'] = '\uf9cd'
"}}}

" NERDTreeã§ãƒ«ãƒ¼ãƒˆã‚’å¤‰æ›´ã—ãŸã‚‰chdirã™ã‚‹
let g:NERDTreeChDirMode = 2

" NERDTress File highlighting
function! NERDTreeHighlightFile(extension, fg, bg, guifg, guibg)
 exec 'autocmd filetype nerdtree highlight ' . a:extension .' ctermbg='. a:bg .' ctermfg='. a:fg .' guibg='. a:guibg .' guifg='. a:guifg
 exec 'autocmd filetype nerdtree syn match ' . a:extension .' #^\s\+.*'. a:extension .'$#'
endfunction
call NERDTreeHighlightFile('py',     'yellow',  'none', 'yellow',  'NONE')
call NERDTreeHighlightFile('md',     'blue',    'none', '#3366FF', 'NONE')
call NERDTreeHighlightFile('yml',    'yellow',  'none', 'yellow',  'NONE')
call NERDTreeHighlightFile('config', 'yellow',  'none', 'yellow',  'NONE')
call NERDTreeHighlightFile('conf',   'yellow',  'none', 'yellow',  'NONE')
call NERDTreeHighlightFile('json',   'yellow',  'none', 'yellow',  'NONE')
call NERDTreeHighlightFile('html',   'yellow',  'none', 'yellow',  'NONE')
call NERDTreeHighlightFile('h',      'blue',  'none', '#3366FF',  'NONE')
call NERDTreeHighlightFile('H',      'blue',  'none', '#3366FF',  'NONE')
call NERDTreeHighlightFile('styl',   'cyan',    'none', 'cyan',    'NONE')
call NERDTreeHighlightFile('css',    'cyan',    'none', 'cyan',    'NONE')
call NERDTreeHighlightFile('rb',     'Red',     'none', 'red',     'NONE')
call NERDTreeHighlightFile('seq',    'Red',     'none', 'red',     'NONE')
call NERDTreeHighlightFile('SEQ',    'Red',     'none', 'red',     'NONE')
call NERDTreeHighlightFile('s',      'Red',     'none', 'red',     'NONE')
call NERDTreeHighlightFile('js',     'Red',     'none', '#ffa500', 'NONE')
call NERDTreeHighlightFile('php',    'Magenta', 'none', '#ff00ff', 'NONE')
"}}}

"neosnippet{{{
let g:neosnippet#snippets_directory='~/.vim/my_snippet'
let g:neosnippet#enable_snipmate_compatibility = 1
let g:deoplete#enable_at_startup = 1
let g:deoplete#omni_patterns = {}
let g:deoplete#auto_complete_delay = 0
let g:deoplete#auto_complete_start_length = 1
let g:deoplete#enable_camel_case = 0
let g:deoplete#enable_ignore_case = 0
let g:deoplete#enable_refresh_always = 0
let g:deoplete#enable_smart_case = 1
let g:deoplete#file#enable_buffer_path = 0
let g:deoplete#max_list = 10000
" SuperTab like snippets behavior
imap <expr><TAB> neosnippet#expandable() <Bar><bar> neosnippet#jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? "\<Down>" : "\<TAB>"
inoremap <expr><S-TAB>  pumvisible() ? "\<C-p>" : "\<S-TAB>"
smap <expr><TAB> neosnippet#expandable() <Bar><bar> neosnippet#jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
"}}}

""Denite{{{
if has('python3')
call denite#custom#option('default', 'prompt', '>')

" denite/insert ãƒ¢ãƒ¼ãƒ‰ã®ã¨ãã¯ï¼ŒC- ã§ç§»å‹•ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
call denite#custom#map('insert', "<C-j>", '<denite:move_to_next_line>')
call denite#custom#map('insert', "<C-k>", '<denite:move_to_previous_line>')

" tabopen ã‚„ vsplit ã®ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰ã‚’å‰²ã‚Šå½“ã¦
call denite#custom#map('insert', "<C-t>", '<denite:do_action:tabopen>')
call denite#custom#map('insert', "<C-v>", '<denite:do_action:vsplit>')
call denite#custom#map('normal', "v", '<denite:do_action:vsplit>')

" jj ã§ denite/insert ã‚’æŠœã‘ã‚‹ã‚ˆã†ã«ã™ã‚‹
call denite#custom#map('insert', 'jj', '<denite:enter_mode:normal>')

" The prefix key.
nnoremap    [denite]   <Nop>
nmap    <Space>f [denite]
"ç¾åœ¨é–‹ã„ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä¸‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã€‚
nnoremap <silent> [denite]f :<C-u>DeniteBufferDir
      \ -direction=topleft -cursor-wrap=true file file:new<CR>
"ãƒãƒƒãƒ•ã‚¡ä¸€è¦§
nnoremap <silent> [denite]b :<C-u>Denite -direction=topleft -cursor-wrap=true buffer<CR>
"ãƒ¬ã‚¸ã‚¹ã‚¿ä¸€è¦§
nnoremap <silent> [denite]r :<C-u>Denite -direction=topleft -cursor-wrap=true -buffer-name=register register<CR>
"æœ€è¿‘ä½¿ç”¨ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§
nnoremap <silent> [denite]m :<C-u>Denite -direction=topleft -cursor-wrap=true file_mru<CR>
"ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ä¸€è¦§
nnoremap <silent> [denite]c :<C-u>Denite -direction=topleft -cursor-wrap=true bookmark<CR>
"ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ã«è¿½åŠ 
nnoremap <silent> [denite]a :<C-u>DeniteBookmarkAdd<CR>

".gitä»¥ä¸‹ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ¤œç´¢
nnoremap <silent> [denite]k :<C-u>Denite -direction=topleft -cursor-wrap=true
      \ -path=`substitute(finddir('.git', './;'), '.git', '', 'g')`
      \ file_rec/git<CR>

call denite#custom#source('file'    , 'matchers', ['matcher_cpsm', 'matcher_fuzzy'])

call denite#custom#source('buffer'  , 'matchers', ['matcher_regexp'])
call denite#custom#source('file_mru', 'matchers', ['matcher_regexp'])

call denite#custom#alias('source', 'file_rec/git', 'file_rec')
call denite#custom#var('file_rec/git', 'command',
  \ ['git', 'ls-files', '-co', '--exclude-standard'])

call denite#custom#map('insert', '<C-N>', '<denite:move_to_next_line>', 'noremap')
call denite#custom#map('insert', '<C-P>', '<denite:move_to_previous_line>', 'noremap')
call denite#custom#map('insert', '<C-W>', '<denite:move_up_path>', 'noremap')

if executable('rg')
  call denite#custom#var('file_rec', 'command',
        \ ['rg', '--files', '--glob', '!.git'])
  call denite#custom#var('grep', 'command', ['rg'])
endif

" ã‚«ãƒ¼ã‚½ãƒ«ä»¥ä¸‹ã®å˜èªã‚’grep
nnoremap <silent> <Space><C-g> :<C-u>DeniteCursorWord grep -buffer-name=search line<CR><C-R><C-W><CR>
" æ™®é€šã«grep
nnoremap <silent> <Space><M-g> :<C-u>Denite -buffer-name=search -mode=normal grep<CR>
" resume previous buffer
nnoremap <silent> ;r :<C-u>Denite -buffer-name=search -resume -mode=normal<CR>

"denite startify
endif
"}}}

"incsearch-fuzzy{{{
map z/ <Plug>(incsearch-fuzzy-/)
map z? <Plug>(incsearch-fuzzy-?)
map zg/ <Plug>(incsearch-fuzzy-stay)
"}}}

"incsearch{{{
map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)
map g/ <Plug>(incsearch-stay)
"}}}

" unite.vim{{{
if !has('python3')
" The prefix key.
nnoremap    [unite]   <Nop>
nmap    <Space>f [unite]

" æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ã§é–‹å§‹ã™ã‚‹
let g:unite_enable_start_insert=1
"æœ€è¿‘é–‹ã„ãŸãƒ•ã‚¡ã‚¤ãƒ«å±¥æ­´ã®ä¿å­˜æ•°
let g:unite_source_file_mru_limit = 50
" å¤§æ–‡å­—å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„
let g:unite_enable_ignore_case = 1
let g:unite_enable_smart_case = 1
"file_mruã®è¡¨ç¤ºãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’æŒ‡å®šã€‚ç©ºã«ã™ã‚‹ã¨è¡¨ç¤ºã‚¹ãƒ”ãƒ¼ãƒ‰ãŒé«˜é€ŸåŒ–ã•ã‚Œã‚‹
let g:unite_source_file_mru_filename_format = ''

" ESCã‚­ãƒ¼ã‚’2å›æŠ¼ã™ã¨çµ‚äº†ã™ã‚‹
au FileType unite nnoremap <silent> <buffer> <ESC><ESC> :q<CR>
au FileType unite inoremap <silent> <buffer> <ESC><ESC> <ESC>:q<CR>
"ç¾åœ¨é–‹ã„ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä¸‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã€‚
"é–‹ã„ã¦ã„ãªã„å ´åˆã¯ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
nnoremap <silent> [unite]f :<C-u>UniteWithBufferDir -buffer-name=files file<CR>
"ãƒãƒƒãƒ•ã‚¡ä¸€è¦§
nnoremap <silent> [unite]b :<C-u>Unite buffer<CR>
"ãƒ¬ã‚¸ã‚¹ã‚¿ä¸€è¦§
nnoremap <silent> [unite]r :<C-u>Unite -buffer-name=register register<CR>
"æœ€è¿‘ä½¿ç”¨ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§
nnoremap <silent> [unite]m :<C-u>Unite file_mru<CR>
"ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ä¸€è¦§
nnoremap <silent> [unite]c :<C-u>Unite bookmark<CR>
"ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ã«è¿½åŠ 
nnoremap <silent> [unite]a :<C-u>UniteBookmarkAdd<CR>
"uniteã‚’é–‹ã„ã¦ã„ã‚‹é–“ã®ã‚­ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚°
autocmd FileType unite call s:unite_my_settings()
"é–¢æ•°æ¤œç´¢
nnoremap <silent> [unite]u :<C-u>Unite outline<CR>
function! s:unite_my_settings() "{{{
	"ESCã§uniteã‚’çµ‚äº†
	nmap <buffer> <ESC> <Plug>(unite_exit)
	"å…¥åŠ›ãƒ¢ãƒ¼ãƒ‰ã®ã¨ãjjã§ãƒãƒ¼ãƒãƒ«ãƒ¢ãƒ¼ãƒ‰ã«ç§»å‹•
	imap <buffer> jj <Plug>(unite_insert_leave)
	"å…¥åŠ›ãƒ¢ãƒ¼ãƒ‰ã®ã¨ãctrl+wã§ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚‚å‰Šé™¤
	imap <buffer> <C-w> <Plug>(unite_delete_backward_path)
	"ctrl+jã§ç¸¦ã«åˆ†å‰²ã—ã¦é–‹ã
	nnoremap <silent> <buffer> <expr> <C-j> unite#do_action('split')
	inoremap <silent> <buffer> <expr> <C-j> unite#do_action('split')
	"ctrl+lã§æ¨ªã«åˆ†å‰²ã—ã¦é–‹ã
	nnoremap <silent> <buffer> <expr> <C-l> unite#do_action('vsplit')
	inoremap <silent> <buffer> <expr> <C-l> unite#do_action('vsplit')
	"ctrl+oã§ãã®å ´æ‰€ã«é–‹ã
	nnoremap <silent> <buffer> <expr> <C-o> unite#do_action('open')
	inoremap <silent> <buffer> <expr> <C-o> unite#do_action('open')
endfunction "}}}

" vinarise
let g:vinarise_enable_auto_detect = 1

" unite-build map
nnoremap <silent> ,vb :Unite build<CR>
nnoremap <silent> ,vcb :Unite build:!<CR>
nnoremap <silent> ,vch :UniteBuildClearHighlight<CR>

{{{start
let g:unite_source_alias_aliases = {
\ "startup_file_mru" : {
\  "source" : "file_mru",
\ },
\ "startup_directory_mru" : {
\  "source" : "directory_mru",
\ },
\}

"\ "startup_session" : {
"\  "source" : "session",
"\ },

" è¡¨ç¤ºæ•°ã®åˆ¶é™
call unite#custom_max_candidates("startup_file_mru", 10)
call unite#custom_max_candidates("startup_directory_mru", 10)

if !exists("g:unite_source_menu_menus")
  let g:unite_source_menu_menus = {}
endif

" :Unite menu:startup ã§ã®å‡ºåŠ›ãƒªã‚¹ãƒˆ
let g:unite_source_menu_menus.startup = {
\ "description" : "startup menu",
\ "command_candidates" : [
\   [ "edit",  "edit" ],
\   [ "vimrc",  "edit " . $VIMHOME . "$MYVIMRC"],
\   [ "gvimrc", "edit " . $VIMHOME . "$MYGVIMRC"],
\   [ "toml", "edit " .  '~/.vim/rc/dein.toml'],
\   [ "toml_lazy", "edit " .  '~/.vim/rc/dein_lazy.toml'],
\   [ "unite-file_mru", "Unite file_mru" ],
\   [ "unite-directory_mru", "Unite directory_mru" ],
\ ]
\}

"\   [ "vimfiler", "VimFiler" ],
"\   [ "unite-howm", "Unite qfixhowm/new qfixhowm:nocache -hide-source-names -no-split" ],
"\   [ "unite-update", "Unite -log neobundle/update" ],

command! UniteStartup
\ Unite
\ output:echo:"===:ğŸ“‘::Menu:===":! menu:startup
\ output:echo:":":!
\ output:echo:"===:â™»::MRU:File:===":! startup_file_mru
\ output:echo:":":!
\ output:echo:"===:â™²::MRU:Directory:===":! startup_directory_mru
\ -hide-source-names
\ -no-split
\ -quick-match

"\ output:echo:"===:âš‘ ::Sessions::===":! startup_session
"\ output:echo:":":!

augroup startup
    autocmd!
    autocmd VimEnter * nested :UniteStartup
augroup END

nnoremap <M-s> :UniteStartup<CR>
"}}}
endif
"}}}

"lightline{{{
"ã‚«ãƒ©ãƒ¼ã‚¹ã‚­ãƒ¼ãƒ ã‚’è‡ªå‹•ã§å¤‰æ›´
augroup LightlineColorscheme
		  autocmd!
		  autocmd ColorScheme * call s:lightline_update()
		augroup END
		function! s:lightline_update()
		  if !exists('g:loaded_lightline')
		    return
		  endif
		  try
		    if g:colors_name =~# 'wombat\|solarized\|landscape\|jellybeans\|Tomorrow\|molokai\|tender\|papercolor\|one\|ayu'"seoul256
		      let g:lightline.colorscheme =
		            \ substitute(substitute(g:colors_name, '-', '_', 'g'), '256.*', '', '')
		      call lightline#init()
		      call lightline#colorscheme()
		      call lightline#update()
		    endif
		  catch
		  endtry
		endfunction

""å¸¸æ™‚ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ã‚¤ãƒ³è¡¨ç¤º
set laststatus=2
			"\ 'colorscheme': 'solarized',

if hostname()!=?'localhost'
		let g:lightline = {
            \ 'active': {
            \   'left': [ [ 'mode', 'paste' ],
            \             [ 'fugitive','dir', 'filename' ],
			\			  ['currentfuncname']]
            \ },
            \ 'component_function': {
            \   'fugitive': 'LightLineFugitive',
            \   'dir': 'LightLineDir',
            \   'readonly': 'LightLineReadonly',
            \   'modified': 'LightLineModified',
            \   'filename': 'LightLineFilename',
            \   'filetype': 'LightLineFiletype',
            \   'fileformat': 'LightLineFileformat',
			\	'currentfuncname': 'LightLineCfi',
  			\ 'percent': 'MyLightLinePercent',
  			\ 'lineinfo': 'MyLightLineLineInfo'
            \ },
		    \ 'separator': { 'left': "\ue0b0", 'right': "\ue0b2" },
      		\ 'subseparator': { 'left': "\ue0b1", 'right': "\ue0b3" }
            \ }

			"\ 'separator': { 'left': "\ue0b4", 'right': "\ue0b6" },
			"\ 'subseparator': { 'left': "\ue0b5", 'right': "\ue0b7" }
		    "\ 'separator': { 'left': "\ue0b0", 'right': "\ue0b2" },
      		"\ 'subseparator': { 'left': "\ue0b1", 'right': "\ue0b3" }
		    "\ 'separator': { 'left': "\ue0b8", 'right': "\ue0ba" },
      		"\ 'subseparator': { 'left': "\ue0b9", 'right': "\ue0bb" }
		    "\ 'separator': { 'left': "\ue0c4", 'right': "\ue0c6" },
      		"\ 'subseparator': { 'left': "\ue0c5", 'right': "\ue0c7" }
            "\ 'separator': { 'left': 'îƒ€', 'right': 'îƒ‚' },
            "\ 'subseparator': { 'left': 'îƒ', 'right': 'îƒƒ' }
endif

function! LightLineModified()
    if &filetype == "help"
        return ""
    elseif &modified
        return "+"
    elseif &modifiable
        return ""
    else
        return ""
    endif
endfunction

                "\ ('' != expand('%:.') ? expand('%:.') : '') .
function! LightLineDir()
    return ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
                \ ('' != expand('%:p:h:t') ? expand('%:p:h:t') : '') .
                \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
endfunction

function! LightLineReadonly()
    if &filetype == "help"
        return ""
    elseif &readonly
        return "î‚¢"
    else
        return ""
    endif
endfunction

function! LightLineFugitive()
    if exists("*fugitive#head")
        let _ = fugitive#head()
        return strlen(_) ? 'î‚ '._ : ''
    endif
    return ''
endfunction

function! LightLineFilename()
    return ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
                \ ('' != expand('%:t') ? expand('%:t') : '[No Name]') .
                \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
endfunction

function! LightLineFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype . ' ' . WebDevIconsGetFileTypeSymbol() : 'no ft') : ''
endfunction

function! LightLineFileformat()
  return winwidth(0) > 70 ? (&fileformat . ' ' . WebDevIconsGetFileFormatSymbol()) : ''
endfunction

function! LightLineCfi()
  if exists('*cfi#format')
    return cfi#format('%s', '')
  end
  return ''
endfunction

let g:lightline.tab = {
      \ 'active': [ 'tabnum', 'filename', 'modified' ],
      \ 'inactive': [ 'tabnum', 'filename', 'modified' ]
      \ }

let g:lightline.tab_component_function = {
      \ 'filename': 'LightlineTabFilename',
      \ 'modified': 'lightline#tab#modified',
      \ 'readonly': 'lightline#tab#readonly',
      \ 'tabnum': 'lightline#tab#tabnum' }

function! LightlineTabFilename(n) abort
  let buflist = tabpagebuflist(a:n)
  let winnr = tabpagewinnr(a:n)
  let _ = pathshorten(expand('#'.buflist[winnr - 1].':f'))
  return _ !=# '' ? _ : '[No Name]'
endfunction

"{{{
"
function! LightlineModified()
  return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! LightlineReadonly()
  return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
endfunction

function! LightlineFilename()
  return ('' != LightlineReadonly() ? LightlineReadonly() . ' ' : '') .
        \ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
        \  &ft == 'unite' ? unite#get_status_string() :
        \  &ft == 'vimshell' ? vimshell#get_status_string() :
        \ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
        \ ('' != LightlineModified() ? ' ' . LightlineModified() : '')
endfunction

function! LightlineFugitive()
  if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
    return fugitive#head()
  else
    return ''
  endif
endfunction

function! LightlineFileencoding()
  return winwidth(0) > 70 ? (&fenc !=# '' ? &fenc : &enc) : ''
endfunction

function! LightlineMode()
  return winwidth(0) > 60 ? lightline#mode() : ''
endfunction
"}}}

function! MyLightLinePercent()
  if &ft !=? 'nerdtree'
    return line('.') * 100 / line('$') . '%'
  else
    return ''
  endif
endfunction

function! MyLightLineLineInfo()
  if &ft !=? 'nerdtree'
    return line('.').':'. col('.')
  else
    return ''
  endif
endfunction
"}}}

"{{{EasyAlign
"" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <Plug>(EasyAlign)
" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)
"}}}

"tagbar{{{
nmap <F8> :TagbarToggle<CR>
let g:tagbar_type_seq = {
	\ 'ctagstype' : 'seq',
	\ 'kinds' : [
		\ 'u:unit'
	\ ],
	\ 'sort' : 0
\ }
"}}}

"" Startify{{{
nnoremap <M-s> :Startify<CR>
"autocmd TabNew * :Startify
noremap <Space>tn :<C-u>tabnew<CR> :Startify<CR>

" èµ·å‹•æ™‚ã®ç”»é¢ã®è¨­å®š
let g:startify_files_number = 10
let g:startify_change_to_dir       = 0
let g:startify_enable_special      = 0
let g:startify_fortune_use_unicode = 1
let g:startify_update_oldfiles     = 1
let g:startify_use_env             = 1
let g:startify_session_autoload       = 1
let g:startify_session_delete_buffers = 1
let g:startify_session_persistence    = 1
let g:startify_session_number = 10
let g:startify_session_sort = 1
let g:startify_enable_special = 1
let g:startify_session_dir = '~/.vim/session'
let NERDTreeHijackNetrw = 0
let g:startify_session_before_save = [
        \ 'echo "Cleaning up before saving.."',
        \ 'silent! NERDTreeTabsClose'
        \ ]
let g:startify_session_savevars = [
           \ 'g:startify_session_savevars',
           \ 'g:startify_session_savecmds',
           \ 'g:random_plugin_use_feature'
           \ ]

let g:startify_list_order = [
        \ ['âš‘  Sessions:'],
        \ 'sessions',
        \ ['â™»  MRU:'],
        \ 'files',
        \ ['â™²  MRU in Current Directory:'],
        \ 'dir',
        \ ['â˜º  Bookmarks:'],
        \ 'bookmarks',
        \ ]

" ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã ã¨ã€æœ€è¿‘ä½¿ã£ãŸãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­ã¯æ•°å­—ãªã®ã§ã€ä½¿ç”¨ã™ã‚‹ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã‚’æŒ‡å®š
let g:startify_custom_indices = ['d', 'f', 'h', 'r', 'i', 'o', 'b']
" ã‚ˆãä½¿ã†ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ã¨ã—ã¦ç™»éŒ²ã—ã¦ãŠã
let g:startify_bookmarks = [
  \ '$VIM/_vimrc',
  \ '$VIM/_gvimrc',
  \ '$VIM/vim80/userautoload/SysSeq.vim',
  \ '$VIM/task.taskpaper',
\ ]

if has('win64')
 let g:startify_custom_header =
            \ startify#fortune#cowsay('', 'â•','â•‘','â•”','â•—','â•','â•š')
 endif
if has('nvim')
 let g:startify_custom_header =
            \ startify#fortune#cowsay('â•','â•‘','â•”','â•—','â•','â•š')
 endif

 autocmd VimEnter *
                \   if !argc()
                \ |   Startify
                "\ |   NERDTree
                \ |   wincmd w
                \ | endif
"}}}

au BufRead,BufNewFile *.ijm set filetype=ijmacro

"accelerated_jk{{{
nmap j <Plug>(accelerated_jk_gj)
nmap k <Plug>(accelerated_jk_gk)
"}}}

""winresizer{{{
"ã‚­ãƒ¼ãƒãƒƒãƒ—å¤‰æ›´
let g:winresizer_start_key = '<M-w>'
"}}}

"QuickRun{{{
" vimprocã§éåŒæœŸå®Ÿè¡Œ
" æˆåŠŸæ™‚ã«ãƒãƒƒãƒ•ã‚¡ã€å¤±æ•—æ™‚ã«QuickFixã§è¡¨ç¤º
" çµæœè¡¨ç¤ºã®ã‚µã‚¤ã‚ºèª¿æ•´ãªã©
let g:quickrun_config = {
    \ '_' : {
        \ 'runner' : 'vimproc',
        \ 'runner/vimproc/updatetime' : 40,
        \ 'outputter' : 'error',
        \ 'outputter/error/success' : 'buffer',
        \ 'outputter/error/error'   : 'quickfix',
        \ 'outputter/buffer/split' : ':botright 8sp',
    \ }
\}

" å®Ÿè¡Œæ™‚ã«å‰å›ã®è¡¨ç¤ºå†…å®¹ã‚’ã‚¯ãƒ­ãƒ¼ã‚º&ä¿å­˜ã—ã¦ã‹ã‚‰å®Ÿè¡Œ
let g:quickrun_no_default_key_mappings = 1
nmap <Space>r :cclose<CR>:write<CR>:QuickRun -mode n<CR>
"}}}

"fugitive{{{
nnoremap [fugitive]  <Nop>
nmap <space>g [fugitive]
nnoremap <silent> [fugitive]s :Gstatus<CR><C-w>T
nnoremap <silent> [fugitive]a :Gwrite<CR>
nnoremap <silent> [fugitive]c :Gcommit-v<CR>
nnoremap <silent> [fugitive]p :Gpush origin master
nnoremap <silent> [fugitive]b :Gblame<CR>
nnoremap <silent> [fugitive]d :Gdiff<CR>
nnoremap <silent> [fugitive]m :Gmerge<CR>
"}}}

"Restart{{{
" :Restart æ™‚ã«å¤‰æ•°ã®å®šç¾©ã‚’è¡Œã†
command! MyRestart Restart --cmd "let g:restarted = 1"

" ã“ã®å¤‰æ•°ã‚’ä½¿ç”¨ã—ã¦ :Restart ãŒè¡Œã‚ã‚ŒãŸã‹ã©ã†ã‹ã®åˆ¤å®šã‚’è¡Œã†
if !exists("g:restarted")
    let $PATH = $PATH . ";C:/cpp/boost"
endif
"}}}

"ale{{{
let g:ale_set_loclist = 0
let g:ale_set_quickfix = 1
let g:ale_open_list = 1
let g:ale_linters = {
\   'python': ['flake8', 'autopep8'],
\}
"}}}

"indentLine{{{
set list listchars=tab:\Â¦\ "spaceãŒå¿…è¦
let g:indentLine_fileTypeExclude = ['help', 'nerdtree','startify','taskpaper','unite']
"}}}

"devicon{{{
if hostname()!=?'localhost'
	" adding the custom source to unite
	let g:webdevicons_enable_unite = 1
	" adding the column to vimfiler
	let g:webdevicons_enable_vimfiler = 1

	let g:WebDevIconsNerdTreeAfterGlyphPadding = ' '
	" adding the flags to NERDTree
	let g:webdevicons_enable_nerdtree = 1
	" whether or not to show the nerdtree brackets around flags
	let g:webdevicons_conceal_nerdtree_brackets = 1
	" Force extra padding in NERDTree so that the filetype icons line up vertically
	let g:WebDevIconsNerdTreeGitPluginForceVAlign = 1

	" change the default character when no match found
	"let g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol = '?'

	" set a byte character marker (BOM) utf-8 symbol when retrieving file encoding
	" disabled by default with no value
	let g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol = 'îŠ‡'

	" enable folder/directory glyph flag (disabled by default with 0)
	let g:WebDevIconsUnicodeDecorateFolderNodes = 1

	" enable open and close folder/directory glyph flags (disabled by default with 0)
	let g:DevIconsEnableFoldersOpenClose = 1

	" enable pattern matching glyphs on folder/directory (enabled by default with 1)
	let g:DevIconsEnableFolderPatternMatching = 1

	" enable file extension pattern matching glyphs on folder/directory (disabled by default with 0)
	let g:DevIconsEnableFolderExtensionPatternMatching = 0
	if exists("g:loaded_webdevicons")
	  call webdevicons#refresh()
	endif
endif

"}}}

"singleton{{{
if hostname()!=?'localhost'
call singleton#enable()
endif
"}}}

"deoplete{{{
let g:deoplete#enable_at_startup = 1
let g:deoplete#omni_patterns = {}
let g:deoplete#auto_complete_delay = 0
let g:deoplete#auto_complete_start_length = 1
let g:deoplete#enable_camel_case = 0
let g:deoplete#enable_ignore_case = 0
let g:deoplete#enable_refresh_always = 0
let g:deoplete#enable_smart_case = 1
let g:deoplete#file#enable_buffer_path = 0
let g:deoplete#max_list = 10000
"}}}

endif
"}}}
