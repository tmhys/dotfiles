"
" ██╗   ██╗██╗███╗   ███╗██████╗  ██████╗
" ██║   ██║██║████╗ ████║██╔══██╗██╔════╝
" ██║   ██║██║██╔████╔██║██████╔╝██║
" ╚██╗ ██╔╝██║██║╚██╔╝██║██╔══██╗██║
"  ╚████╔╝ ██║██║ ╚═╝ ██║██║  ██║╚██████╗
"   ╚═══╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝
" Last Change: 02-May-2019.
" Maintainer: TH

"最初に書く必要あり
set encoding=utf8

"その他の設定ファイル読み込み
runtime! userautoload/*.vim

""dein{{{
if executable('git')
	if &compatible
		set nocompatible
	endif

	" dein path
	let s:dein_dir = expand('~/.cache/dein')
	let s:dein_repo_dir = s:dein_dir . '/repos/github.com/Shougo/dein.vim'

	" install dein.vim if not found
	if &runtimepath !~# '/dein.vim'
	  if !isdirectory(s:dein_repo_dir)
	    execute '!git clone https://github.com/Shougo/dein.vim' s:dein_repo_dir
	  endif
	  set runtimepath+=~/.cache/dein/repos/github.com/Shougo/dein.vim
	endif

	if dein#load_state(s:dein_dir)
	  call dein#begin(s:dein_dir)

	  "toml設定{{{
	  "Plugin list
	  let g:rc_dir    = expand('~/.vim/rc')
	  let s:toml      = g:rc_dir . '/dein.toml'
	  let s:color     = g:rc_dir . '/color.toml'
	  let s:lazy_toml = g:rc_dir . '/dein_lazy.toml'

	  "キャッシュしておく
	  call dein#load_toml(s:toml,      {'lazy': 0})
	  call dein#load_toml(s:color,     {'lazy': 0})
	  call dein#load_toml(s:lazy_toml, {'lazy': 1})
	 " }}}

	  call dein#end()
	  call dein#save_state()
	endif

	"Required
	filetype plugin indent on
	syntax enable

	" If you want to install not installed plugins on startup.
	if dein#check_install()
	  call dein#install()
	endif

command! DU :call dein#update()
command! DR :call dein#recache_runtimepath()

endif
"}}}

"基本設定{{{
"カラー設定{{{
set background=dark "light dark
"let ayucolor="light"  "mirage dark
"colorscheme ayu "nord atom-dark badwolf hybrid newspaper wombat molokai solarized evening desert morning elford koehler landscape papercolor one seoul256
"Chrosh上で256カラーに必要
set termguicolors
"}}}

let g:vimproc#download_windows_dll = 1

"ステータスライン常時表示
set laststatus=2

"ラグ対策
set lazyredraw

"シンタックスハイライト関係{{{
syntax on
set autoindent
"set expandtab
set tabstop=4
set shiftwidth=4
"カーソルラインはvim-auto-cursorlineに統合
"set cursorline
"set cursorcolumn
set number
set signcolumn=yes

filetype plugin on
"}}}

"Quickfixウィンドウ開く{{{
autocmd QuickFixCmdPost *grep* cwindow
"}}}

"ripgrep{{{
if executable('rg')
    set grepprg=rg\ --vimgrep\ --no-heading
    set grepformat=%f:%l:%c:%m,%f:%l:%m
endif
"}}}

"{{{
" Similarly, we can apply it to fzf#vim#grep. To use ripgrep instead of ag:
command! -bang -nargs=* Rg
  \ call fzf#vim#grep(
  \   'rg --column --line-number --no-heading --color=always '.shellescape(<q-args>), 1,
  \   <bang>0 ? fzf#vim#with_preview('up:60%')
  \           : fzf#vim#with_preview('right:50%:hidden', '?'),
  \   <bang>0)
"}}}

"バックアップファイルの保存先変更{{{
"augroup vimrc-auto-mkdir  " {{{
"  autocmd!
"  autocmd BufWritePre * call s:auto_mkdir(expand('<afile>:p:h'), v:cmdbang)
"  function! s:auto_mkdir(dir, force)  " {{{
"    if !isdirectory(a:dir) && (a:force ||
"    \    input(printf('"%s" does not exist. Create? [y/N]', a:dir)) =~? '^y\%[es]$')
"      call mkdir(iconv(a:dir, &encoding, &termencoding), 'p')
"    endif
"  endfunction  " }}}
"augroup END  " }}}

let $DATE = strftime("%Y%m%d_%H%M%S")

set backup
set writebackup
set backupdir=$HOME/.vimbackup
au BufWritePre * let &bex = '.' .strftime("%Y%m%d_%H%M%S")
set undodir=$HOME/.vimbackup
set undofile
set noswapfile

"自動的にセッション保存{{{
au VimLeave * cclose
au VimLeave * NERDTreeClose
au VimLeave	* mks! ~/.vim/session/$DATE.vim
"}}}

"対になる括弧点滅{{{
set showmatch
set matchtime=1
"}}}

"文末スペース削除{{{
autocmd BufWritePre * :%s/\s\+$//ge
"}}}

"補完{{{
set completeopt=menuone
for k in split("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",'\zs')
  exec "imap " . k . " " . k . "<C-N><C-P>"
endfor

let g:python3_host_prog='C:\Python37\python.exe'
set pythonthreedll=C:\Python37\python37.dll
"}}}

"相対行番号表示&トグル
"nnoremap <F3> :<C-u>setlocal relativenumber!<CR>

"同期スクロールトグル
nnoremap <F4> :<C-u>set scrollbind!<CR>

"IME状態に応じたカーソル色設定{{{
if has('multi_byte_ime')
  highlight Cursor guifg=#000d18 guibg=#8faf9f gui=bold
  highlight CursorIM guifg=NONE guibg=#ecbcbc
endif
"}}}

"折りたたみ設定{{{
au FileType vim setlocal foldmethod=marker
au FileType seq setlocal foldmethod=marker
"}}}

"}}}

set scrolloff=10
set backspace=indent,eol,start
set matchpairs+=「:」,『:』,（:）,【:】,《:》,〈:〉,［:］,‘:’,“:”,｛:｝
"set virtualedit=all
set ignorecase
set smartcase

" 終了時に保存するセッションオプションを設定する{{{
let g:restart_sessionoptions
    \ = 'blank,buffers,curdir,folds,help,localoptions,tabpages'
"}}}

"カレントウィンドウを新規タブで開き直す{{{
if v:version >= 700
    nnoremap <M-n> :call OpenNewTab()<CR>
    function! OpenNewTab()
        let f = expand("%:p")
        execute ":q"
        execute ":tabnew ".f
    endfunction
endif
"}}}

"}}}

"""キーマップ{{{
"command line window
"nnoremap : q:a
"nnoremap / q/a

" for masui special.
noremap g<CR> g;
"Quickfixウインドウと干渉する
"nnoremap <CR> :<C-u>w<CR>

"行末までヤンク
nnoremap Y y$
"xとsでヤンクしない
nnoremap x "_x
nnoremap s "_s
nnoremap S "_S

"---<F6>タイムスタンプを挿入{{{
nmap <F6> <ESC>a<C-R>=strftime("%Y/%m/%d %H:%M")<CR><ESC>
inoremap <F6> <ESC>a<C-R>=strftime("%Y/%m/%d %H:%M")<CR>
nmap <F6>a <ESC>a<C-R>=strftime("%Y/%m/%d %H:%M")<CR> appended by <ESC>
inoremap <F6>a <ESC>a<C-R>=strftime("%Y/%m/%d %H:%M")<CR> appended by
nmap <F6>m <ESC>a<C-R>=strftime("%Y/%m/%d %H:%M")<CR> modified by <ESC>
inoremap <F6>m <ESC>a<C-R>=strftime("%Y/%m/%d %H:%M")<CR> modified by
"}}}

"ESCキー連打
nnoremap <silent> <ESC><ESC> :<C-u>nohlsearch<CR>:Undiff<CR>
nnoremap <silent> <ESC><ESC><ESC><ESC> :Restart<CR>

"jj,kkでEcs
inoremap jj <Esc>
inoremap hhh <Esc>
inoremap lll <Esc>
inoremap kkk <Esc>

"アクティブウィンドウ移動
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
nnoremap <C-h> <C-w>h

" j, k による移動を折り返されたテキストでも自然に振る舞うように変更
nnoremap j gj
nnoremap k gk
"S-h,S-lで行頭、行末
nnoremap <S-h> ^
nnoremap <S-l> $
" vを二回で行末まで選択
vnoremap v $h
" 検索後にジャンプした際に検索単語を画面中央に持ってくる
nnoremap n nzz
nnoremap N Nzz
"インサートモードでも移動
inoremap <c-j> <down>
inoremap <c-k> <up>
inoremap <c-h> <left>
inoremap <c-l> <right>

" TABにて対応ペアにジャンプ
nnoremap <TAB> %
vnoremap <TAB> %

" 行を移動
nnoremap <C-Up> "zdd<Up>"zP
nnoremap <C-Down> "zdd"zp
" 複数行を移動
vnoremap <C-Up> "zx<Up>"zP`[V`]
vnoremap <C-Down> "zx"zp`[V`]
"新規タブ
"noremap <Space>tn :<C-u>tabnew<CR> :UniteStartup<CR>
noremap <Space>tn :<C-u>tabnew<CR>
nnoremap <C-Tab> gt
nnoremap <S-C-Tab> gT

""縦分割版gf
nnoremap gs :vertical wincmd f<CR>

"最初にヤンクした文字列を繰り返しペースト
vnoremap <Space>p "0p

"ディレクトリ自動で移動
set autochdir&vim

"<Space>cd で編集ファイルのカレントディレクトリへと移動{{{
command! -nargs=? -complete=dir -bang CD  call s:ChangeCurrentDir('<args>', '<bang>')
function! s:ChangeCurrentDir(directory, bang)
    if a:directory == ''
        lcd %:p:h
    else
        execute 'lcd' . a:directory
    endif
    if a:bang == ''
        pwd
    endif
endfunction

" Change current directory.
nnoremap <silent> <Space>cd :<C-u>CD<CR>
"}}}

"カーソル下の単語をハイライトする
nnoremap <silent> <Space><Space> *N

"カーソル下の単語をハイライトしてから置換する
nmap # <Space><Space>:%s/<C-r>///g<Left><Left>

"1行挿入する
nnoremap <Space>o :<C-u>call append(expand('.'), '')<Cr>j

"改行する
nnoremap <M-o> i<CR><ESC>

"ESCで確実にIMEオフ
inoremap <ESC> <ESC>:set iminsert=0<CR>

"括弧補完{{{
inoremap { {}<ESC>i
inoremap [ []<ESC>i
inoremap ( ()<ESC>i
inoremap < <><ESC>i
inoremap * **<ESC>i
inoremap ' ''<ESC>i
"}}}

""VDsplitをWinmergeライクに{{{
nnoremap <M-j> ]c
nnoremap <M-k> [c
nnoremap <M-h> <C-w>hdo
nnoremap <M-l> <C-w>hdp
"}}}

""vimrcの編集再読み込み{{{
"編集
command! Evimrc :e $MYVIMRC
command! Egvimrc :e $MYGVIMRC
command! Etoml :e C:\Users\thtom\.vim\rc\dein.toml
command! Eltoml :e C:\Users\thtom\.vim\rc\dein_lazy.toml
"command! Evimrc :e  $HOME/dotfiles/_vimrc
"command! Egvimrc :e $HOME/dotfiles/_gvimrc
command! Esysseq :e $VIM/vim81/userautoload/SysSeq.vim
"保存したら再読み込み
augroup reload_vimrc
	autocmd!
	autocmd BufWritePost $MYVIMRC nested source $MYVIMRC
	autocmd BufWritePost $MYVIMRC nested source $MYGVIMRC
	autocmd BufWritePost $MYVIMRC nested source $MYGVIMRC
	autocmd BufWritePost $MYVIMRC nested call lightline#update()
	autocmd BufWritePost C:\Users\thtom\.vim\rc\dein.toml nested source $MYVIMRC
	autocmd BufWritePost C:\Users\thtom\.vim\rc\dein.toml nested call dein#recache_runtimepath()
	autocmd BufWritePost C:\Users\thtom\.vim\rc\dein_lazy.toml nested source $MYVIMRC
	autocmd BufWritePost C:\Users\thtom\.vim\rc\dein_lazy.toml nested call dein#recache_runtimepath()
	autocmd BufWritePost $MYGVIMRC nested source $MYGVIMRC
	autocmd BufWritePost SysSeq.vim nested source $MYGVIMRC
	autocmd BufWritePost SysSeq.vim nested source $MYGVIMRC
augroup END
"}}}

"{{{Quickfix windowトグル
function! s:toggle_quickfix_window()
  let _ = winnr('$')
  cclose
  if _ == winnr('$')
  cwindow
  endif
endfunction
"}}}
nnoremap <M-q> :<C-u>call <SID>toggle_quickfix_window()<CR>

"QuickFix 横画面分割で結果を表示
au FileType qf nnoremap <S-CR> <C-w><CR><C-w>L

" マーク設定 : {{{
" 基本マップ
nnoremap [Mark] <Nop>
nmap m [Mark]

" 現在位置をマーク
if !exists('g:markrement_char')
    let g:markrement_char = [
    \     'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    \     'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
    \ ]
endif
nnoremap <silent>[Mark]m :<C-u>call <SID>AutoMarkrement()<CR>
function! s:AutoMarkrement()
    if !exists('b:markrement_pos')
        let b:markrement_pos = 0
    else
        let b:markrement_pos = (b:markrement_pos + 1) % len(g:markrement_char)
    endif
    execute 'mark' g:markrement_char[b:markrement_pos]
    echo 'marked' g:markrement_char[b:markrement_pos]
endfunction

" 次/前のマーク
nnoremap [Mark]n ]`
nnoremap [Mark]N [`

" 一覧表示
nnoremap [Mark]l :<C-u>marks<CR>

" 前回終了位置に移動
autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line('$') | exe 'normal g`"' | endif

" バッファ読み込み時にマークを初期化
autocmd BufReadPost * delmarks!

" }}}

""スクリプト実行{{{
autocmd BufNewFile,BufRead *.rb nnoremap <C-e> :!ruby %<CR>
autocmd BufNewFile,BufRead *.py nnoremap <C-e> :!py -3 %<CR>
autocmd BufNewFile,BufRead *.pl nnoremap <C-e> :!perl %<CR>
autocmd BufNewFile,BufRead *.cs nnoremap <C-e> :!csc /target:winexe %<CR>
autocmd BufNewFile,BufRead *.js nnoremap <C-e> :!electron .<CR>
"}}}
"}}}

"ctags{{{
let g:tagbar_ctags_bin = 'C:\tools\ctags58j2bin\ctags.exe'
set fileformats=unix,dos,mac
set fileencodings=utf-8,sjis

set tags=.tags;$HOME

function! s:execute_ctags() abort
  " 探すタグファイル名
  let tag_name = '.tags'
  " ディレクトリを遡り、タグファイルを探し、パス取得
  let tags_path = findfile(tag_name, '.;')
  " タグファイルパスが見つからなかった場合
  if tags_path ==# ''
    return
  endif

  " タグファイルのディレクトリパスを取得
  " `:p:h`の部分は、:h filename-modifiersで確認
  let tags_dirpath = fnamemodify(tags_path, ':p:h')
  " 見つかったタグファイルのディレクトリに移動して、ctagsをバックグラウンド実行（エラー出力破棄）
  execute 'silent !cd' tags_dirpath '&& ctags -R -f' tag_name '2> /dev/null &'
endfunction

augroup ctags
  autocmd!
  autocmd BufWritePost * call s:execute_ctags()
augroup END
"}}}

"{{{外部ソフト
if hostname()!=?'localhost'
	"WinMerge
	command! WinMerge :! C:\"Program Files"\WinMerge\WinMergeU /e/u/wr/maximize/fl "%:p:t"
	"ImageJ マクロ実行
	"command! ImageJ :
endif
"}}}

"deinがないときの各プラグイン設定{{{
if !executable('git')
"switch{{{
let g:switch_mapping = "-"
let g:switch_custom_definitions =
    \ [
    \   ['on', 'off']
    \ ]
"}}}

"NERDTree{{{
map <C-n> :NERDTreeToggle<CR>
nnoremap <silent> <expr> <C-n> g:NERDTree.IsOpen() ? "\:NERDTreeClose<CR>" : bufexists(expand('%')) ? "\:NERDTreeFind<CR>" : "\:NERDTree<CR>"
"""bookmark初期表示
let g:NERDTreeShowBookmarks=1
"lag対策
let g:NERDTreeLimitedSyntax = 1

let NERDTreeIgnore = ['.dat$','.exe$','.dbg$','.bak$','.dll$']


""NERDTree矢印変更{{{
let g:WebDevIconsNerdTreeAfterGlyphPadding = ''
let g:NERDTreeDirArrows = 1
let g:NERDTreeDirArrowExpandable  = '▶'
let g:NERDTreeDirArrowCollapsible = '▼'
"let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols['seq'] = '\uf9cd'
"}}}

" NERDTreeでルートを変更したらchdirする
let g:NERDTreeChDirMode = 2

" NERDTress File highlighting
function! NERDTreeHighlightFile(extension, fg, bg, guifg, guibg)
 exec 'autocmd filetype nerdtree highlight ' . a:extension .' ctermbg='. a:bg .' ctermfg='. a:fg .' guibg='. a:guibg .' guifg='. a:guifg
 exec 'autocmd filetype nerdtree syn match ' . a:extension .' #^\s\+.*'. a:extension .'$#'
endfunction
call NERDTreeHighlightFile('py',     'yellow',  'none', 'yellow',  'NONE')
call NERDTreeHighlightFile('md',     'blue',    'none', '#3366FF', 'NONE')
call NERDTreeHighlightFile('yml',    'yellow',  'none', 'yellow',  'NONE')
call NERDTreeHighlightFile('config', 'yellow',  'none', 'yellow',  'NONE')
call NERDTreeHighlightFile('conf',   'yellow',  'none', 'yellow',  'NONE')
call NERDTreeHighlightFile('json',   'yellow',  'none', 'yellow',  'NONE')
call NERDTreeHighlightFile('html',   'yellow',  'none', 'yellow',  'NONE')
call NERDTreeHighlightFile('h',      'blue',  'none', '#3366FF',  'NONE')
call NERDTreeHighlightFile('H',      'blue',  'none', '#3366FF',  'NONE')
call NERDTreeHighlightFile('styl',   'cyan',    'none', 'cyan',    'NONE')
call NERDTreeHighlightFile('css',    'cyan',    'none', 'cyan',    'NONE')
call NERDTreeHighlightFile('rb',     'Red',     'none', 'red',     'NONE')
call NERDTreeHighlightFile('seq',    'Red',     'none', 'red',     'NONE')
call NERDTreeHighlightFile('SEQ',    'Red',     'none', 'red',     'NONE')
call NERDTreeHighlightFile('s',      'Red',     'none', 'red',     'NONE')
call NERDTreeHighlightFile('js',     'Red',     'none', '#ffa500', 'NONE')
call NERDTreeHighlightFile('php',    'Magenta', 'none', '#ff00ff', 'NONE')
"}}}

"neosnippet{{{
let g:neosnippet#snippets_directory='~/.vim/my_snippet'
let g:neosnippet#enable_snipmate_compatibility = 1
let g:deoplete#enable_at_startup = 1
let g:deoplete#omni_patterns = {}
let g:deoplete#auto_complete_delay = 0
let g:deoplete#auto_complete_start_length = 1
let g:deoplete#enable_camel_case = 0
let g:deoplete#enable_ignore_case = 0
let g:deoplete#enable_refresh_always = 0
let g:deoplete#enable_smart_case = 1
let g:deoplete#file#enable_buffer_path = 0
let g:deoplete#max_list = 10000
" SuperTab like snippets behavior
imap <expr><TAB> neosnippet#expandable() <Bar><bar> neosnippet#jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? "\<Down>" : "\<TAB>"
inoremap <expr><S-TAB>  pumvisible() ? "\<C-p>" : "\<S-TAB>"
smap <expr><TAB> neosnippet#expandable() <Bar><bar> neosnippet#jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
"}}}

""Denite{{{
if has('python3')
call denite#custom#option('default', 'prompt', '>')

" denite/insert モードのときは，C- で移動できるようにする
call denite#custom#map('insert', "<C-j>", '<denite:move_to_next_line>')
call denite#custom#map('insert', "<C-k>", '<denite:move_to_previous_line>')

" tabopen や vsplit のキーバインドを割り当て
call denite#custom#map('insert', "<C-t>", '<denite:do_action:tabopen>')
call denite#custom#map('insert', "<C-v>", '<denite:do_action:vsplit>')
call denite#custom#map('normal', "v", '<denite:do_action:vsplit>')

" jj で denite/insert を抜けるようにする
call denite#custom#map('insert', 'jj', '<denite:enter_mode:normal>')

" The prefix key.
nnoremap    [denite]   <Nop>
nmap    <Space>f [denite]
"現在開いているファイルのディレクトリ下のファイル一覧。
nnoremap <silent> [denite]f :<C-u>DeniteBufferDir
      \ -direction=topleft -cursor-wrap=true file file:new<CR>
"バッファ一覧
nnoremap <silent> [denite]b :<C-u>Denite -direction=topleft -cursor-wrap=true buffer<CR>
"レジスタ一覧
nnoremap <silent> [denite]r :<C-u>Denite -direction=topleft -cursor-wrap=true -buffer-name=register register<CR>
"最近使用したファイル一覧
nnoremap <silent> [denite]m :<C-u>Denite -direction=topleft -cursor-wrap=true file_mru<CR>
"ブックマーク一覧
nnoremap <silent> [denite]c :<C-u>Denite -direction=topleft -cursor-wrap=true bookmark<CR>
"ブックマークに追加
nnoremap <silent> [denite]a :<C-u>DeniteBookmarkAdd<CR>

".git以下のディレクトリ検索
nnoremap <silent> [denite]k :<C-u>Denite -direction=topleft -cursor-wrap=true
      \ -path=`substitute(finddir('.git', './;'), '.git', '', 'g')`
      \ file_rec/git<CR>

call denite#custom#source('file'    , 'matchers', ['matcher_cpsm', 'matcher_fuzzy'])

call denite#custom#source('buffer'  , 'matchers', ['matcher_regexp'])
call denite#custom#source('file_mru', 'matchers', ['matcher_regexp'])

call denite#custom#alias('source', 'file_rec/git', 'file_rec')
call denite#custom#var('file_rec/git', 'command',
  \ ['git', 'ls-files', '-co', '--exclude-standard'])

call denite#custom#map('insert', '<C-N>', '<denite:move_to_next_line>', 'noremap')
call denite#custom#map('insert', '<C-P>', '<denite:move_to_previous_line>', 'noremap')
call denite#custom#map('insert', '<C-W>', '<denite:move_up_path>', 'noremap')

if executable('rg')
  call denite#custom#var('file_rec', 'command',
        \ ['rg', '--files', '--glob', '!.git'])
  call denite#custom#var('grep', 'command', ['rg'])
endif

" カーソル以下の単語をgrep
nnoremap <silent> <Space><C-g> :<C-u>DeniteCursorWord grep -buffer-name=search line<CR><C-R><C-W><CR>
" 普通にgrep
nnoremap <silent> <Space><M-g> :<C-u>Denite -buffer-name=search -mode=normal grep<CR>
" resume previous buffer
nnoremap <silent> ;r :<C-u>Denite -buffer-name=search -resume -mode=normal<CR>

"denite startify
endif
"}}}

"incsearch-fuzzy{{{
map z/ <Plug>(incsearch-fuzzy-/)
map z? <Plug>(incsearch-fuzzy-?)
map zg/ <Plug>(incsearch-fuzzy-stay)
"}}}

"incsearch{{{
map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)
map g/ <Plug>(incsearch-stay)
"}}}

" unite.vim{{{
if !has('python3')
" The prefix key.
nnoremap    [unite]   <Nop>
nmap    <Space>f [unite]

" 挿入モードで開始する
let g:unite_enable_start_insert=1
"最近開いたファイル履歴の保存数
let g:unite_source_file_mru_limit = 50
" 大文字小文字を区別しない
let g:unite_enable_ignore_case = 1
let g:unite_enable_smart_case = 1
"file_mruの表示フォーマットを指定。空にすると表示スピードが高速化される
let g:unite_source_file_mru_filename_format = ''

" ESCキーを2回押すと終了する
au FileType unite nnoremap <silent> <buffer> <ESC><ESC> :q<CR>
au FileType unite inoremap <silent> <buffer> <ESC><ESC> <ESC>:q<CR>
"現在開いているファイルのディレクトリ下のファイル一覧。
"開いていない場合はカレントディレクトリ
nnoremap <silent> [unite]f :<C-u>UniteWithBufferDir -buffer-name=files file<CR>
"バッファ一覧
nnoremap <silent> [unite]b :<C-u>Unite buffer<CR>
"レジスタ一覧
nnoremap <silent> [unite]r :<C-u>Unite -buffer-name=register register<CR>
"最近使用したファイル一覧
nnoremap <silent> [unite]m :<C-u>Unite file_mru<CR>
"ブックマーク一覧
nnoremap <silent> [unite]c :<C-u>Unite bookmark<CR>
"ブックマークに追加
nnoremap <silent> [unite]a :<C-u>UniteBookmarkAdd<CR>
"uniteを開いている間のキーマッピング
autocmd FileType unite call s:unite_my_settings()
"関数検索
nnoremap <silent> [unite]u :<C-u>Unite outline<CR>
function! s:unite_my_settings() "{{{
	"ESCでuniteを終了
	nmap <buffer> <ESC> <Plug>(unite_exit)
	"入力モードのときjjでノーマルモードに移動
	imap <buffer> jj <Plug>(unite_insert_leave)
	"入力モードのときctrl+wでバックスラッシュも削除
	imap <buffer> <C-w> <Plug>(unite_delete_backward_path)
	"ctrl+jで縦に分割して開く
	nnoremap <silent> <buffer> <expr> <C-j> unite#do_action('split')
	inoremap <silent> <buffer> <expr> <C-j> unite#do_action('split')
	"ctrl+lで横に分割して開く
	nnoremap <silent> <buffer> <expr> <C-l> unite#do_action('vsplit')
	inoremap <silent> <buffer> <expr> <C-l> unite#do_action('vsplit')
	"ctrl+oでその場所に開く
	nnoremap <silent> <buffer> <expr> <C-o> unite#do_action('open')
	inoremap <silent> <buffer> <expr> <C-o> unite#do_action('open')
endfunction "}}}

" vinarise
let g:vinarise_enable_auto_detect = 1

" unite-build map
nnoremap <silent> ,vb :Unite build<CR>
nnoremap <silent> ,vcb :Unite build:!<CR>
nnoremap <silent> ,vch :UniteBuildClearHighlight<CR>

{{{start
let g:unite_source_alias_aliases = {
\ "startup_file_mru" : {
\  "source" : "file_mru",
\ },
\ "startup_directory_mru" : {
\  "source" : "directory_mru",
\ },
\}

"\ "startup_session" : {
"\  "source" : "session",
"\ },

" 表示数の制限
call unite#custom_max_candidates("startup_file_mru", 10)
call unite#custom_max_candidates("startup_directory_mru", 10)

if !exists("g:unite_source_menu_menus")
  let g:unite_source_menu_menus = {}
endif

" :Unite menu:startup での出力リスト
let g:unite_source_menu_menus.startup = {
\ "description" : "startup menu",
\ "command_candidates" : [
\   [ "edit",  "edit" ],
\   [ "vimrc",  "edit " . $VIMHOME . "$MYVIMRC"],
\   [ "gvimrc", "edit " . $VIMHOME . "$MYGVIMRC"],
\   [ "toml", "edit " .  '~/.vim/rc/dein.toml'],
\   [ "toml_lazy", "edit " .  '~/.vim/rc/dein_lazy.toml'],
\   [ "unite-file_mru", "Unite file_mru" ],
\   [ "unite-directory_mru", "Unite directory_mru" ],
\ ]
\}

"\   [ "vimfiler", "VimFiler" ],
"\   [ "unite-howm", "Unite qfixhowm/new qfixhowm:nocache -hide-source-names -no-split" ],
"\   [ "unite-update", "Unite -log neobundle/update" ],

command! UniteStartup
\ Unite
\ output:echo:"===:📑::Menu:===":! menu:startup
\ output:echo:":":!
\ output:echo:"===:♻::MRU:File:===":! startup_file_mru
\ output:echo:":":!
\ output:echo:"===:♲::MRU:Directory:===":! startup_directory_mru
\ -hide-source-names
\ -no-split
\ -quick-match

"\ output:echo:"===:⚑ ::Sessions::===":! startup_session
"\ output:echo:":":!

augroup startup
    autocmd!
    autocmd VimEnter * nested :UniteStartup
augroup END

nnoremap <M-s> :UniteStartup<CR>
"}}}
endif
"}}}

"lightline{{{
"カラースキームを自動で変更
augroup LightlineColorscheme
		  autocmd!
		  autocmd ColorScheme * call s:lightline_update()
		augroup END
		function! s:lightline_update()
		  if !exists('g:loaded_lightline')
		    return
		  endif
		  try
		    if g:colors_name =~# 'wombat\|solarized\|landscape\|jellybeans\|Tomorrow\|molokai\|tender\|papercolor\|one\|ayu'"seoul256
		      let g:lightline.colorscheme =
		            \ substitute(substitute(g:colors_name, '-', '_', 'g'), '256.*', '', '')
		      call lightline#init()
		      call lightline#colorscheme()
		      call lightline#update()
		    endif
		  catch
		  endtry
		endfunction

""常時ステータスライン表示
set laststatus=2
			"\ 'colorscheme': 'solarized',

if hostname()!=?'localhost'
		let g:lightline = {
            \ 'active': {
            \   'left': [ [ 'mode', 'paste' ],
            \             [ 'fugitive','dir', 'filename' ],
			\			  ['currentfuncname']]
            \ },
            \ 'component_function': {
            \   'fugitive': 'LightLineFugitive',
            \   'dir': 'LightLineDir',
            \   'readonly': 'LightLineReadonly',
            \   'modified': 'LightLineModified',
            \   'filename': 'LightLineFilename',
            \   'filetype': 'LightLineFiletype',
            \   'fileformat': 'LightLineFileformat',
			\	'currentfuncname': 'LightLineCfi',
  			\ 'percent': 'MyLightLinePercent',
  			\ 'lineinfo': 'MyLightLineLineInfo'
            \ },
		    \ 'separator': { 'left': "\ue0b0", 'right': "\ue0b2" },
      		\ 'subseparator': { 'left': "\ue0b1", 'right': "\ue0b3" }
            \ }

			"\ 'separator': { 'left': "\ue0b4", 'right': "\ue0b6" },
			"\ 'subseparator': { 'left': "\ue0b5", 'right': "\ue0b7" }
		    "\ 'separator': { 'left': "\ue0b0", 'right': "\ue0b2" },
      		"\ 'subseparator': { 'left': "\ue0b1", 'right': "\ue0b3" }
		    "\ 'separator': { 'left': "\ue0b8", 'right': "\ue0ba" },
      		"\ 'subseparator': { 'left': "\ue0b9", 'right': "\ue0bb" }
		    "\ 'separator': { 'left': "\ue0c4", 'right': "\ue0c6" },
      		"\ 'subseparator': { 'left': "\ue0c5", 'right': "\ue0c7" }
            "\ 'separator': { 'left': '', 'right': '' },
            "\ 'subseparator': { 'left': '', 'right': '' }
endif

function! LightLineModified()
    if &filetype == "help"
        return ""
    elseif &modified
        return "+"
    elseif &modifiable
        return ""
    else
        return ""
    endif
endfunction

                "\ ('' != expand('%:.') ? expand('%:.') : '') .
function! LightLineDir()
    return ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
                \ ('' != expand('%:p:h:t') ? expand('%:p:h:t') : '') .
                \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
endfunction

function! LightLineReadonly()
    if &filetype == "help"
        return ""
    elseif &readonly
        return ""
    else
        return ""
    endif
endfunction

function! LightLineFugitive()
    if exists("*fugitive#head")
        let _ = fugitive#head()
        return strlen(_) ? ''._ : ''
    endif
    return ''
endfunction

function! LightLineFilename()
    return ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
                \ ('' != expand('%:t') ? expand('%:t') : '[No Name]') .
                \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
endfunction

function! LightLineFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype . ' ' . WebDevIconsGetFileTypeSymbol() : 'no ft') : ''
endfunction

function! LightLineFileformat()
  return winwidth(0) > 70 ? (&fileformat . ' ' . WebDevIconsGetFileFormatSymbol()) : ''
endfunction

function! LightLineCfi()
  if exists('*cfi#format')
    return cfi#format('%s', '')
  end
  return ''
endfunction

let g:lightline.tab = {
      \ 'active': [ 'tabnum', 'filename', 'modified' ],
      \ 'inactive': [ 'tabnum', 'filename', 'modified' ]
      \ }

let g:lightline.tab_component_function = {
      \ 'filename': 'LightlineTabFilename',
      \ 'modified': 'lightline#tab#modified',
      \ 'readonly': 'lightline#tab#readonly',
      \ 'tabnum': 'lightline#tab#tabnum' }

function! LightlineTabFilename(n) abort
  let buflist = tabpagebuflist(a:n)
  let winnr = tabpagewinnr(a:n)
  let _ = pathshorten(expand('#'.buflist[winnr - 1].':f'))
  return _ !=# '' ? _ : '[No Name]'
endfunction

"{{{
"
function! LightlineModified()
  return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! LightlineReadonly()
  return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
endfunction

function! LightlineFilename()
  return ('' != LightlineReadonly() ? LightlineReadonly() . ' ' : '') .
        \ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
        \  &ft == 'unite' ? unite#get_status_string() :
        \  &ft == 'vimshell' ? vimshell#get_status_string() :
        \ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
        \ ('' != LightlineModified() ? ' ' . LightlineModified() : '')
endfunction

function! LightlineFugitive()
  if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
    return fugitive#head()
  else
    return ''
  endif
endfunction

function! LightlineFileencoding()
  return winwidth(0) > 70 ? (&fenc !=# '' ? &fenc : &enc) : ''
endfunction

function! LightlineMode()
  return winwidth(0) > 60 ? lightline#mode() : ''
endfunction
"}}}

function! MyLightLinePercent()
  if &ft !=? 'nerdtree'
    return line('.') * 100 / line('$') . '%'
  else
    return ''
  endif
endfunction

function! MyLightLineLineInfo()
  if &ft !=? 'nerdtree'
    return line('.').':'. col('.')
  else
    return ''
  endif
endfunction
"}}}

"{{{EasyAlign
"" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <Plug>(EasyAlign)
" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)
"}}}

"tagbar{{{
nmap <F8> :TagbarToggle<CR>
let g:tagbar_type_seq = {
	\ 'ctagstype' : 'seq',
	\ 'kinds' : [
		\ 'u:unit'
	\ ],
	\ 'sort' : 0
\ }
"}}}

"" Startify{{{
nnoremap <M-s> :Startify<CR>
"autocmd TabNew * :Startify
noremap <Space>tn :<C-u>tabnew<CR> :Startify<CR>

" 起動時の画面の設定
let g:startify_files_number = 10
let g:startify_change_to_dir       = 0
let g:startify_enable_special      = 0
let g:startify_fortune_use_unicode = 1
let g:startify_update_oldfiles     = 1
let g:startify_use_env             = 1
let g:startify_session_autoload       = 1
let g:startify_session_delete_buffers = 1
let g:startify_session_persistence    = 1
let g:startify_session_number = 10
let g:startify_session_sort = 1
let g:startify_enable_special = 1
let g:startify_session_dir = '~/.vim/session'
let NERDTreeHijackNetrw = 0
let g:startify_session_before_save = [
        \ 'echo "Cleaning up before saving.."',
        \ 'silent! NERDTreeTabsClose'
        \ ]
let g:startify_session_savevars = [
           \ 'g:startify_session_savevars',
           \ 'g:startify_session_savecmds',
           \ 'g:random_plugin_use_feature'
           \ ]

let g:startify_list_order = [
        \ ['⚑  Sessions:'],
        \ 'sessions',
        \ ['♻  MRU:'],
        \ 'files',
        \ ['♲  MRU in Current Directory:'],
        \ 'dir',
        \ ['☺  Bookmarks:'],
        \ 'bookmarks',
        \ ]

" デフォルトだと、最近使ったファイルの先頭は数字なので、使用するアルファベットを指定
let g:startify_custom_indices = ['d', 'f', 'h', 'r', 'i', 'o', 'b']
" よく使うファイルをブックマークとして登録しておく
let g:startify_bookmarks = [
  \ '$VIM/_vimrc',
  \ '$VIM/_gvimrc',
  \ '$VIM/vim80/userautoload/SysSeq.vim',
  \ '$VIM/task.taskpaper',
\ ]

if has('win64')
 let g:startify_custom_header =
            \ startify#fortune#cowsay('', '═','║','╔','╗','╝','╚')
 endif
if has('nvim')
 let g:startify_custom_header =
            \ startify#fortune#cowsay('═','║','╔','╗','╝','╚')
 endif

 autocmd VimEnter *
                \   if !argc()
                \ |   Startify
                "\ |   NERDTree
                \ |   wincmd w
                \ | endif
"}}}

au BufRead,BufNewFile *.ijm set filetype=ijmacro

"accelerated_jk{{{
nmap j <Plug>(accelerated_jk_gj)
nmap k <Plug>(accelerated_jk_gk)
"}}}

""winresizer{{{
"キーマップ変更
let g:winresizer_start_key = '<M-w>'
"}}}

"QuickRun{{{
" vimprocで非同期実行
" 成功時にバッファ、失敗時にQuickFixで表示
" 結果表示のサイズ調整など
let g:quickrun_config = {
    \ '_' : {
        \ 'runner' : 'vimproc',
        \ 'runner/vimproc/updatetime' : 40,
        \ 'outputter' : 'error',
        \ 'outputter/error/success' : 'buffer',
        \ 'outputter/error/error'   : 'quickfix',
        \ 'outputter/buffer/split' : ':botright 8sp',
    \ }
\}

" 実行時に前回の表示内容をクローズ&保存してから実行
let g:quickrun_no_default_key_mappings = 1
nmap <Space>r :cclose<CR>:write<CR>:QuickRun -mode n<CR>
"}}}

"fugitive{{{
nnoremap [fugitive]  <Nop>
nmap <space>g [fugitive]
nnoremap <silent> [fugitive]s :Gstatus<CR><C-w>T
nnoremap <silent> [fugitive]a :Gwrite<CR>
nnoremap <silent> [fugitive]c :Gcommit-v<CR>
nnoremap <silent> [fugitive]p :Gpush origin master
nnoremap <silent> [fugitive]b :Gblame<CR>
nnoremap <silent> [fugitive]d :Gdiff<CR>
nnoremap <silent> [fugitive]m :Gmerge<CR>
"}}}

"Restart{{{
" :Restart 時に変数の定義を行う
command! MyRestart Restart --cmd "let g:restarted = 1"

" この変数を使用して :Restart が行われたかどうかの判定を行う
if !exists("g:restarted")
    let $PATH = $PATH . ";C:/cpp/boost"
endif
"}}}

"ale{{{
let g:ale_set_loclist = 0
let g:ale_set_quickfix = 1
let g:ale_open_list = 1
let g:ale_linters = {
\   'python': ['flake8', 'autopep8'],
\}
"}}}

"indentLine{{{
set list listchars=tab:\¦\ "spaceが必要
let g:indentLine_fileTypeExclude = ['help', 'nerdtree','startify','taskpaper','unite']
"}}}

"devicon{{{
if hostname()!=?'localhost'
	" adding the custom source to unite
	let g:webdevicons_enable_unite = 1
	" adding the column to vimfiler
	let g:webdevicons_enable_vimfiler = 1

	let g:WebDevIconsNerdTreeAfterGlyphPadding = ' '
	" adding the flags to NERDTree
	let g:webdevicons_enable_nerdtree = 1
	" whether or not to show the nerdtree brackets around flags
	let g:webdevicons_conceal_nerdtree_brackets = 1
	" Force extra padding in NERDTree so that the filetype icons line up vertically
	let g:WebDevIconsNerdTreeGitPluginForceVAlign = 1

	" change the default character when no match found
	"let g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol = '?'

	" set a byte character marker (BOM) utf-8 symbol when retrieving file encoding
	" disabled by default with no value
	let g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol = ''

	" enable folder/directory glyph flag (disabled by default with 0)
	let g:WebDevIconsUnicodeDecorateFolderNodes = 1

	" enable open and close folder/directory glyph flags (disabled by default with 0)
	let g:DevIconsEnableFoldersOpenClose = 1

	" enable pattern matching glyphs on folder/directory (enabled by default with 1)
	let g:DevIconsEnableFolderPatternMatching = 1

	" enable file extension pattern matching glyphs on folder/directory (disabled by default with 0)
	let g:DevIconsEnableFolderExtensionPatternMatching = 0
	if exists("g:loaded_webdevicons")
	  call webdevicons#refresh()
	endif
endif

"}}}

"singleton{{{
if hostname()!=?'localhost'
call singleton#enable()
endif
"}}}

"deoplete{{{
let g:deoplete#enable_at_startup = 1
let g:deoplete#omni_patterns = {}
let g:deoplete#auto_complete_delay = 0
let g:deoplete#auto_complete_start_length = 1
let g:deoplete#enable_camel_case = 0
let g:deoplete#enable_ignore_case = 0
let g:deoplete#enable_refresh_always = 0
let g:deoplete#enable_smart_case = 1
let g:deoplete#file#enable_buffer_path = 0
let g:deoplete#max_list = 10000
"}}}

endif
"}}}
