###########
# lightline
###########
[[plugins]]
repo = 'itchyny/lightline.vim'
depends  = [# {{{
    'delphinus/lightline-delphinus',
	'tpope/vim-fugitive',
	'majutsushi/tagbar',
    'ryanoasis/vim-devicons'
    ]# }}}
hook_add = '''"{{{
    function! s:lightline_update()
      if !exists('g:loaded_lightline')
    	    return
      endif
    	  try
       if g:colors_name =~# 'wombat\|solarized\|landscape\|jellybeans\|Tomorrow\|molokai\|tender\|papercolor\|one\|ayu'"seoul256
    	  let g:lightline.colorscheme = substitute(substitute(g:colors_name, '-', '_', 'g'), '256.*', '', '') .
              \ (g:colors_name ==# 'solarized' ? '_' . &background : '')
          call lightline#init()
          call lightline#colorscheme()
          call lightline#update()
        endif
      catch
      endtry
    endfunction

    "call s:lightline_update()

    command! -bar LightlineUpdate    call lightline#init()| call lightline#colorscheme()| call lightline#update()


    let g:lightline = {
        \ 'active': {
        \   'left': [ [ 'mode', 'paste' ],
        \             ['fugitive', 'dir', 'filename'],
    	\			  ['currenttag']],
    	\   'right': [['lineinfo'],
		\			  ['filetype','qfstatusline', 'fileformat','fileencoding','percent'],
		\			  ['asyncrun_e','asyncrun_s', 'lsp_errors', 'lsp_warnings', 'lsp_ok']]
        \ },
        \ 'component_function': {
        \   'mode': 'LightLinemode',
        \   'fugitive': 'LightLineFugitive',
        \   'readonly': 'LightLineReadonly',
        \   'modified': 'LightLineModified',
        \   'filename': 'LightLineFilename',
        \   'filetype': 'LightLineFiletype',
        \   'fileicon': 'LightLineFileicon',
        \   'fileformat': 'LightLineFileformat',
		\	'fileencoding': 'LightlineFileencoding',
    	\	'currenttag': 'LightLineCurrentTag',
    	\   'percent': 'MyLightLinePercent',
    	\   'lineinfo': 'MyLightLineLineInfo'
        \ },
    	\ 'component_expand': {
	    \ 'asyncrun_e': 'LightLineAsyncrun_e',
	    \ 'asyncrun_s': 'LightLineAsyncrun_s',
	    \ 'lsp_warnings': 'LightlineLSPWarnings',
      	\ 'lsp_errors':   'LightlineLSPErrors',
      	\ 'lsp_ok':       'LightlineLSPOk',
		\ 'qfstatusline': 'qfstatusline#Update'
		\ },
    	\ 'component_type':   {
	    \ 'asyncrun_e': 'error',
	    \ 'asyncrun_s': 'middle',
		\ 'lsp_warnings': 'warning',
      	\ 'lsp_errors':   'error',
      	\ 'lsp_ok':       'middle',
		\ 'qfstatusline': 'error'
		\ },
        \ 'separator': { 'left': "\ue0b0", 'right': "\ue0b2" },
    	\ 'subseparator': { 'left': "\ue0b1", 'right': "\ue0b3" }
        \ }

        "   'dir': 'LightLineDir',
        "   'mode': 'raw',
        "   'fugitive': 'raw',
        "   'dir'	  : 'raw',
        "   'readonly': 'raw',
        "   'modified': 'raw',
        "   'filename': 'raw',
        "   'filetype': 'raw',
        "   'fileicon': 'raw',
        "   'fileformat': 'raw',
		"	'fileencoding': 'raw',
    	"	'currenttag': 'raw',
    	"   'percent': 'raw',
    	"   'lineinfo': 'raw',

    let g:Qfstatusline#UpdateCmd = function('lightline#update')

    function! LightLineModified() abort
        if &filetype == "help"
            return ""
        elseif &modified
            return "+"
        elseif &modifiable
            return ""
        else
            return ""
        endif
    endfunction

    function! LightLinemode() abort
	  if &ft == 'nerdtree'
        return 'NERDTREE'
	elseif &ft == 'tagbar'
        return 'TAGBAR'
      else
		return lightline#mode()
    endfunction

    function! LightLineDir() abort
	  if &ft == 'nerdtree' || &ft == 'tagbar'
        return ''
      else
        return ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
                    \ ('' != expand('%:p:h:t') ? expand('%:p:h:t') : '')
    endfunction

    function! LightLineAsyncrun_e() abort
	  if &ft == 'seq'&&g:asyncrun_status=='failure'
        return '%{g:asyncrun_status}'
      else
        return ''
    endfunction
    function! LightLineAsyncrun_s() abort
	  if &ft == 'seq'&&g:asyncrun_status!='failure'
        return '%{g:asyncrun_status}'
      else
        return ''
    endfunction

	function! LightlineFileencoding() abort
	  if &ft == 'nerdtree' || &ft == 'tagbar'
        return ''
      else
	    return winwidth(0) > 70 ? (&fenc !=# '' ? &fenc : &enc) : ''
	endfunction

    function! LightLineReadonly() abort
	  	if &filetype == "help"
            return ""
        elseif &readonly
            return ""
		elseif &ft == 'nerdtree' || &ft == 'tagbar'
            return ""
        endif
    endfunction

    function! LightLineFugitive() abort
	  if &ft == 'nerdtree' || &ft == 'tagbar'
	    return ''
	  else
        let s:branch = FugitiveHead()
        if len(s:branch) > 0
          return "" . s:branch " powerline branch glyph prepended when on actual branch
        else
          "return "detached HEAD " . FugitiveHead(7)
          return ""
      endif
    endfun

    function! LightLineFilename() abort
	    if &ft == 'nerdtree' || &ft == 'tagbar'
          return ''
	    else
          return ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
            	\ ('' != expand('%:t') ? expand('%:t') : '[No Name]') .
            	\ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
    endfunction
            	" ('' != LightLineFileicon() ? ' ' . LightLineFileicon() : '').

    function! LightLineFiletype() abort
	  if &ft == 'nerdtree' || &ft == 'tagbar'
        return ''
      else
      return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype . ' ' . WebDevIconsGetFileTypeSymbol() : 'no ft') : ''
    endfunction

    function! LightLineFileicon() abort
	  if &ft == 'nerdtree' || &ft == 'tagbar'
        return ''
      else
      return winwidth(0) > 70 ? (strlen(&filetype) ?   WebDevIconsGetFileTypeSymbol(): '') : ''
    endfunction

    function! LightLineFileformat() abort
	  if &ft == 'nerdtree' || &ft == 'tagbar'
        return ''
      else
      return winwidth(0) > 70 ? (WebDevIconsGetFileFormatSymbol()): ''
    endfunction

    "function! LightLineFileformat()
    "  return winwidth(0) > 70 ? (&fileformat . ' ' . WebDevIconsGetFileFormatSymbol()): ''
    "endfunction

    function! LightLineCurrentTag() abort
	  if !empty(globpath(&rtp, 'autoload/tagbar.vim'))
    	return tagbar#currenttag('%s', '')
	  else
	  	return ''
    endfunction

	function! LightlineLSPWarnings() abort
	  if &ft != 'seq' || &ft != 'nerdtree' || &ft != 'tagbar'
	  	let l:counts = lsp#get_buffer_diagnostics_counts()
	  	return l:counts.warning == 0 ? '' : printf('W:%d', l:counts.warning)
	  else
		return ''
	  endif
	endfunction

	function! LightlineLSPErrors() abort
	  if &ft != 'seq'|| &ft != 'nerdtree' || &ft != 'tagbar'
	    let l:counts = lsp#get_buffer_diagnostics_counts()
	    return l:counts.error == 0 ? '' : printf('E:%d', l:counts.error)
	  else
		return ''
	  endif
	endfunction

	function! LightlineLSPOk() abort
	  if &ft == 'nerdtree' || &ft == 'tagbar'
		return ''
	  elseif &ft !=? 'seq'
	    let l:counts =  lsp#get_buffer_diagnostics_counts()
	    let l:total = l:counts.error + l:counts.warning
	    return l:total == 0 ? 'OK' : ''
	  else
		return ''
	  endif
	endfunction

    "右上にworking directory
    let g:lightline.tabline = {'right': [['cd']]}
    let g:lightline.component = {'cd': '%.35(%{fnamemodify(getcwd(), ":~")}%)'}

    "NERDTreeで表示省略
    function! MyLightLinePercent() abort
	  if &ft == 'nerdtree' || &ft == 'tagbar'
        return ''
      else
        return line('.') * 100 / line('$') . '%'
    endfunction

    function! MyLightLineLineInfo() abort
	  if &ft == 'nerdtree' || &ft == 'tagbar'
        return ''
      else
        return line('.').':'. col('.')
    endfunction

	augroup MyLightline
		autocmd!
		""autocmd CursorHold,CursorHoldI,ColorScheme * silent call s:lightline_update()
		autocmd CursorHold,CursorHoldI,ColorScheme * silent call s:lightline_update() | LightlineUpdate
	  	autocmd User lsp_diagnostics_updated call lightline#update()
	augroup END
"}}}'''

[[plugins]]
repo = 'delphinus/lightline-delphinus'

[[plugins]]
repo = 'tpope/vim-fugitive'
hook_add = '''"{{{
    nnoremap [fugitive]  <Nop>
    nmap <space>g [fugitive]
    nnoremap <silent> [fugitive]s :Git status<CR>
    nnoremap <silent> [fugitive]a :Git add .<CR>
    nnoremap <silent> [fugitive]c :Git commit<CR>
    nnoremap <silent> [fugitive]p :Git push origin master<CR>
    nnoremap <silent> [fugitive]b :Git blame<CR>
    nnoremap <silent> [fugitive]d :Git diff<CR>
    nnoremap <silent> [fugitive]m :Git merge<CR>
"}}}'''

###########
# fuzzyfinder
###########
[[plugins]]
repo = 'ctrlpvim/ctrlp.vim'
depends  = [# {{{
	'mattn/ctrlp-matchfuzzy',
	'mattn/ctrlp-mark',
	'hara/ctrlp-colorscheme'
    ]# }}}
hook_add = '''"{{{
    " The prefix key.
    nnoremap    [ctrlp]   <Nop>
    nmap    <Space>f [ctrlp]
    "
	""let g:ctrlp_line_prefix= '> '
    nnoremap <silent> [ctrlp]f :<C-u>CtrlPCurFile<CR>
    nnoremap <silent> [ctrlp]b :<C-u>CtrlPBuffer<CR>
    nnoremap <silent> [ctrlp]m :<C-u>CtrlPMRUFiles<CR>
    nnoremap <silent> [ctrlp]v :<C-u>CtrlP $HOME/dotfiles/vimrc<CR>
    nnoremap <silent> [ctrlp]a :<C-u>CtrlPMixed<CR>
    nnoremap <silent> [ctrlp]c :<C-u>CtrlPColorscheme<CR>
    nnoremap <silent> [ctrlp]k :<C-u>CtrlPMark<CR>
    let g:ctrlp_clear_cache_on_exit = 0   " 終了時キャッシュをクリアしない
    " 遅延再描画
    let g:ctrlp_lazy_update = 1
    if v:version  == 802  && has("patch1665")
    	let g:ctrlp_match_func = {'match': 'ctrlp_matchfuzzy#matcher'}
    endif
    " CtrlPのウィンドウ最大高さ
    autocmd VimEnter,VimResized *  let g:ctrlp_match_window = 'max:' . string(min([(&lines/3), 20]) - 1)

    "何故かワークしない
    let g:ctrlp_custom_ignore = {
      \ 'dir':  '\v[\/]\.(git|hg|svn)$',
      \ 'file': '\v\.(exe|so|dll)$',
      \ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
      \ }

  	let g:ctrlp_reuse_window = 'quickfix'
    " # lightline.vimで表示しているステータスラインとの衝突を避けるため
    let g:ctrlp_buffer_func = {
    	\ 'enter': 'CtrlPEnter',
    	\ 'exit': 'CtrlPLeave',
    \ }

    " # ctrlpに入るとき，ステータスラインの表示をoffに
    function! CtrlPEnter()
    	set laststatus=0
		let b:qs_local_disable=1
    endfunction

    " # ctrlpから出るとき，ステータスラインの表示をonに
    function! CtrlPLeave()
    	set laststatus=2
		let b:qs_local_disable=0
    endfunction
"}}}'''

[[plugins]]
repo = 'mattn/ctrlp-matchfuzzy'

[[plugins]]
repo = 'mattn/ctrlp-mark'

[[plugins]]
repo = 'hara/ctrlp-colorscheme'

[[plugins]]
repo = 'mattn/vim-ctrlp-syntax-highlight'

[[plugins]]
repo = 'ryanoasis/vim-devicons'

###########
# lsp
###########
[[plugins]]
repo = 'prabirshrestha/vim-lsp'
hook_add = '''"{{{
    function! s:on_lsp_buffer_enabled() abort
    	setlocal omnifunc=lsp#complete
    	setlocal signcolumn=yes
    	nmap <buffer> gd <plug>(lsp-definition)
    	nmap <buffer> <f2> <plug>(lsp-rename)
    	nnoremap <buffer> <F5> :LspDocumentFormat<CR>
    	autocmd BufWritePre *.py LspDocumentFormatSync
    	"inoremap <expr> <cr> pumvisible() ? "\<c-y>\<cr>" : "\<cr>"
    endfunction

    augroup lsp_install
      au!
      autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
    augroup END
    command! LspDebug let lsp_log_verbose=1 | let lsp_log_file = expand('~/lsp.log')

    let g:lsp_diagnostics_enabled       = 1
    let g:lsp_diagnostics_echo_cursor   = 1
    let g:asyncomplete_auto_popup       = 2
    let g:asyncomplete_auto_completeopt = 1
    let g:asyncomplete_popup_delay      = 1
    let g:lsp_text_edit_enabled         = 0

    inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
    inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
    inoremap <expr> <cr>    pumvisible() ? asyncomplete#close_popup() : "\<cr>"

    let g:lsp_signs_error                    = {'text': '❌'}
    let g:lsp_signs_warning                  = {'text': '⚠️', 'icon': '/path/to/some/icon'}
    let g:lsp_signs_hint                     = {'text': '💡'}
    let g:lsp_diagnostics_signs_error        = {'text': '❌'}
    let g:lsp_diagnostics_signs_warning      = {'text': '⚠️'}
    let g:lsp_diagnostics_signs_information  = {'text': '❓'}
    let g:lsp_diagnostics_signs_hint         = {'text': '💡'}
"}}}'''

###########
# complete
###########
[[plugins]]
repo = 'prabirshrestha/asyncomplete.vim'
depends  = [# {{{
	'prabirshrestha/asyncomplete-buffer.vim',
	'hrsh7th/vim-vsnip',
	'hrsh7th/vim-vsnip-integ'
    ]# }}}

[[plugins]]
repo = 'prabirshrestha/asyncomplete-buffer.vim'
hook_add = '''"{{{
call asyncomplete#register_source(asyncomplete#sources#buffer#get_source_options({
    \ 'name': 'buffer',
    \ 'allowlist': ['*'],
    \ 'blocklist': ['go'],
    \ 'completor': function('asyncomplete#sources#buffer#completor'),
    \ 'config': {
    \    'max_buffer_size': 5000000,
    \  },
    \ }))
"}}}'''

# [[plugins]]
# repo = 'hotoolong/asyncomplete-tabnine.vim'
# build = 'powershell.exe .\install.ps1'
# hook_add = '''"{{{
# call asyncomplete#register_source(asyncomplete#sources#tabnine#get_source_options({
#   \ 'name': 'tabnine',
#   \ 'allowlist': ['*'],
#   \ 'completor': function('asyncomplete#sources#tabnine#completor'),
#   \ 'config': {
#   \   'line_limit': 1000,
#   \   'max_num_result': 20,
#   \  },
#   \ }))
# "}}}'''

###########
# snippet
###########
[[plugins]]
repo = 'hrsh7th/vim-vsnip'

[[plugins]]
repo = 'hrsh7th/vim-vsnip-integ'
hook_add = '''"{{{
	"imapでマッピングしないとsnippet展開後のtabキーの挙動が変、いまいちよくわ
	"からん
    imap <expr> <Tab>  pumvisible() ? "\<C-n>" :
				\vsnip#available(1)   ? '<Plug>(vsnip-expand-or-jump)':
				\"\<Tab>"

    imap <expr> <S-Tab> pumvisible() ? "\<C-p>" :
				\vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      :
				\"\<S-Tab>"

    smap <expr> <Tab> pumvisible() ? "\<C-n>" :
				\vsnip#available(1)   ? '<Plug>(vsnip-expand-or-jump)':
				\"\<Tab>"

    smap <expr> <S-Tab> pumvisible() ? "\<C-p>" :
				\vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      :
				\"\<S-Tab>"

    imap <expr> <cr>    pumvisible() ? asyncomplete#close_popup() : "\<cr>"
	imap <c-space> <Plug>(asyncomplete_force_refresh)

"}}}'''

###########
# tools
###########
[[plugins]]
# 以前の行で開く FIXME
repo = 'farmergreg/vim-lastplace'
